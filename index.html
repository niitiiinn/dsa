<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div class="logo">
            <h1>DSA Problems</h1>
        </div>
        <nav>
            <ul>
                <li>
                    <div class="dropdown">
                        <button class="dropbtn"><a href="#arrays">Arrays</a></button>
                        <div class="dropdown-content">
                            <a href="#arr1">Enter an array from user and display all the value ?</a>
                            <a href="#arr2">Enter an array from user and print the array in reverse order ?</a>
                            <a href="#arr3">Enter an array from user and copy the array into second array ?</a>
                            <a href="#arr4">Enter an array from user and copy it into another array in reverse order ?</a>
                            <a href="#arr5">Enter an array from user and print the number which is even ?</a>
                            <a href="#arr6">Enter an array from user and print the number which is positive ?</a>
                            <a href="#arr7">Enter an array from user and square all the values of array ?</a>
                            <a href="#arr8">Enter an array from user and find maximum and minimum value?</a>
                            <a href="#arr9">Enter an array from user and find the k-th smallest value?</a>
                            <a href="#arr10">Enter an array from user and add all values ?</a>
                            <a href="#arr11">Enter an array from user and find the duplicate values?</a>
                            <a href="#arr12">Enter an array from user and remove the duplicate values and fill with zero?</a>
                            <a href="#arr13">Enter an array from user and count the duplicate values?</a>
                            <a href="#arr14">Enter an array from user and print all possible combinations of the elements?</a>
                            <a href="#arr15">Enter an array from user and print all the palindrone numbers?</a>
                            <a href="#arr16">Enter two arrays from the user and check they are same or not?</a>
                            <a href="#arr17">Merge the two sorted arrays into one array but in sorted order?</a>
                            <a href="#arr18">Find the local minima in the array?</a>
                            <a href="#arr19">Find the local maxima in the array?</a>
                            <a href="#arr20">Trapping Rain Water Problem.</a>
                        </div>
                    </div>
                </li>
                <li>
                    <div class="dropdown">
                        <button class="dropbtn"><a href="#2Darrays">2D Arrays</a></button>
                        <div class="dropdown-content">
                            <a href="#2Darr1">Enter a matrix of 4 rows and 2 columns from the user display it in matrix format?</a>
                            <a href="#2Darr2">Enter two Matrices from user, add the matrices and display the answer?</a>
                            <a href="#2Darr3">Enter two Matrices from user, subtract the matrices and display the answer?</a>
                            <a href="#2Darr4"> Enter two Matrices from user, multiply the matrices and display the answer?</a>
                            <a href="#2Darr5"> Enter a Matrix from user, copy it in another matrix of same size?</a>
                            <a href="#2Darr6">Enter the Matrix from user, multiply it with a scalar value and display the answer?</a>
                            <a href="#2Darr7">Create a tic tac toe game using 2D Arrays.</a>
                        </div>
                    </div>
                </li>
                
                <li><div class="dropdown">
                    <button class="dropbtn"><a href="#strings">Strings</a></button>
                    <div class="dropdown-content">
                        <a href="#str1">Convert in uppercase ?</a> 
                        <a href="#str2">Convert into lowercase ?</a> 
                        <a href="#str3">Convert into sentence case ?</a> 
                        <a href="#str4">Convert into title case ?</a> 
                        <a href="#str5">Convert into toggle case ?</a> 
                        <a href="#str6">Final length of the string ?</a> 
                        <a href="#str7">Compare those string ?</a> 
                        <a href="#str8">Concatenate the string ?</a> 
                        <a href="#str9">Copy that string into another string ?</a> 
                        <a href="#str10">Enter bound number and print character on that bound ?</a> 
                        <a href="#str11">Check its palindrome or not?</a> 
                        <a href="#str12">Print each character in new line ?</a> 
                        <a href="#str13">Copy reverse order into another string ?</a> 
                        <a href="#str14">2 strings and print difference each character ?</a> 
                        <a href="#str15">Enter a character , it is exist or not ?</a> 
                        <a href="#str16">Enter a character if it is exist then print the bound number ?</a> 
                        <a href="#str17">Count all vowels ?</a> 
                        <a href="#str18">Convert into integer?</a> 
                        <a href="#str19">Convert into float?</a> 
                        <a href="#str21">Count the number of characters, words, spaces and lines.</a> 
                        <a href="#str22">Print all the possiblities of a string i.e. "abcde".</a> 
                        <a href="#str23">Sort the string in ascending order.</a> 
                        <a href="#str24">Enter a sentence from user and then enter the word and count the occurence of that word in the sentence.</a> 
                        <a href="#str25">Enter a sentence from user and then enter the word and replace that word by another word.</a> 
                        <a href="#str26">Trim the spaces from both ends (if any)</a> 
                        <a href="#str27">Create a split function which splits the first word and return. Split(string,index)</a> 
                        <a href="#str28">Display the string with text alignment option (1 for left, 2 for center, 3 right)</a> 
                        <a href="#str29">Create a dictionary having 10 words and their meaning with following operations. [create, delete,search]</a> 
                        <a href="#str30">Convert characters into string. [for example take 10 characters]</a> 
                    </div>
                </div></li>
                <li><div class="dropdown">
                    <button class="dropbtn"><a href="#stacks">Stacks</a></button>
                    <div class="dropdown-content">
                        <a href="#stk1">Implement the operations of stack in an integer array (push, pop, peek, isempty, isfull) </a> 
                        <a href="#stk2">Implement the operations of stack in an string array (push, pop, peek, isempty, isfull) </a> 
                        <a href="#stk3">Reverse of string using stack </a> 
                        <a href="#stk4">Single bracket matching using stack </a> 
                        <a href="#stk5">Convert the expression into infix to prefix </a> 
                        <a href="#stk6">Convert the expression into infix to postfix </a> 
                        <a href="#stk7">Evaluate the prefix expression </a> 
                        <a href="#stk8">Evaluate the postfix expression </a> 
                        <a href="#stk9">Implement the tower of hanoi </a> 
                        <a href="#stk10">Application of recursion using stack </a> 
                        <a href="#stk11">CREATE TWO INTEGER STACKS IN A SINGLE ARRAY</a> 
                        <a href="#stk12">Implement the operations of stack dynamically of integers (push, pop, peek, isempty, isfull) </a> 
                        <a href="#stk13">Implement the operations of stack dynamically of string (push, pop, peek, isempty, isfull) </a> 
                        <a href="#stk14">Sort the stack using recursion </a> </div>
                </div></li>
                <li><div class="dropdown">
                    <button class="dropbtn"><a href="#queues">Queues</a></button>
                    <div class="dropdown-content">
                        <a href="#que1">Implement the operations of simple queue in an integer array (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que2">Implement the operations of simple queue in an string array (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que3">Implement the operations of queue dynamically of integers (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que4">Implement the operations of queue dynamically of string (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que5">Implement the operations of circular queue in an integer array (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que6">Implement the operations of circular queue in an string array (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que7">Implement the operations of priority queue in an integer array (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que8">Implement the operations of priority queue in an string array (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que9">Implement the operations of double ended queue in an integer array (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que10">Implement the operations of double ended queue in an string array (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que11">Implement the operations of priority queue dynamically of integers (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que12">Implement the operations of priority queue dynamically of string (insert, delete, peek, isempty, isfull) </a> 
                        <a href="#que13">Find a tour that visits all stations </a> 
                        <a href="#que14">Longest Valid String </a> 
                        <a href="#que15">Next larger Element </a> 
                        <a href="#que16">Next smaller element </a> 
                        <a href="#que17">Queue based approach for first non repeating character in a stream </a> 
                        <a href="#que18">Reverse first k elements of queue </a> 
                        <a href="#que19">Queue Reversal </a> 
                        <a href="#que20">Rotten-oranges </a>
                    </div>
                </div></li>
                <li><div class="dropdown">
                    <button class="dropbtn"><a href="#ll">Linked list</a></button>
                    <div class="dropdown-content" >
                        <a href="#ll1">1. IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING INTEGER VALUES </a> 
                        <a href="#ll2">2. IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING INTEGER VALUES </a> 
                        <a href="#ll3">3. IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING INTEGER VALUES  </a> 
                        <a href="#ll4">4. IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING INTEGER VALUES </a> 
                        <a href="#ll5">5. IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING STRING VALUES </a> 
                        <a href="#ll6">6. IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING STRING VALUES  </a> 
                        <a href="#ll7">7. IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING STRING VALUES  </a> 
                        <a href="#ll8">8. IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING STRING VALUES </a> 
                        <a href="#ll9">9. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, ADD THEM AND DISPLAY THE ANSWER. </a> 
                        <a href="#ll10">10. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, SUBTRACT THEM AND DISPLAY THE ANSWER. </a> 
                        <a href="#ll11">11. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, MULTIPLY THEM AND DISPLAY THE ANSWER. </a> 


                    </div>
                </div></li>
                <li><div class="dropdown">
                    <button class="dropbtn"><a href="#graphs">Graphs</a></button>
                    <div class="dropdown-content" >
                        <a href="#">que1</a>
                        <a href="#">que2</a>
                    </div>
                </div></li>
                <li><div class="dropdown" >
                    <button class="dropbtn"><a href="#tree">Trees</a></button>
                    <div class="dropdown-content" style="right: 0;">
                        <a href="#tree3"> 3. PRINT LEFT VIEW OF BINARY TREE</a> 
                        <a href="#tree1"> 1. CONSTRUCT BINARY TREE FROM PREORDER AND INORDER TRAVERSAL</a> 
                        <a href="#tree2"> 2. BINARY TREE LEVEL ORDER TRAVERSAL</a> 
                        <a href="#tree4"> 4. DISPLAY THE RIGHT VIEW OF BINARY TREE</a> 
                        <a href="#tree5"> 5. CONSTRUCT BINARY TREE FROM POSTORDER AND INORDER TRAVERSAL</a> 
                        <a href="#tree6"> 6. FIND THE MAXIMUM DEPTH OF BINARY TREE</a> 
                        <a href="#tree7"> 7. CREATE BINARY SEARCH TREE USING ARRAYS (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</a> 
                        <a href="#tree8"> 8. CREATE BINARY SEARCH TREE DYNAMICALLY (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)</a> 
                        <a href="#tree9"> 9. FIND INORDER PREDECESSOR AND INORDER SUCCESSOR OF BINARY SEARCH TREE (DYNAMICALLY REPRESENTED)</a> 
                        <a href="#tree10"> 10. CHECK WHETHER BINARY SEARCH TREE CONTAINS DEAD END</a> 
                        <a href="#tree11"> 11. CREATE BINARY TREE TO BINARY SEARCH TREE THROUGH ARRAY.</a> 
                        <a href="#tree12"> 12. FIND KTH LARGEST ELEMENT IN BINARY SEARCH TREE THROUGH ARRAY</a> 
                        <a href="#tree13"> 13. FIND KTH SMALLEST ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY</a> 
                        <a href="#tree14"> 14. PRINT PREORDER TRAVERSAL TO POSTORDER TRAVERSAL OF BINARY SEARCH TREE</a> 
                        <a href="#tree15"> 15. CONSTRUCT BINARY SEARCH TREE FROM GIVEN PREORDER TRAVERSAL THROUGH ARRAYS</a> 
                        <a href="#tree16"> 16. CONSTRUCT BINARY SEARCH TREE FROM GIVEN POSTORDER TRAVERSAL THROUGH ARRAYS</a> 
                        <a href="#tree17"> 17. CREATE STRICTLY BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a> 
                        <a href="#tree18"> 18. CREATE ALMOST COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a> 
                        <a href="#tree19"> 19. CREATE COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</a> 
                        <a href="#tree20"> 20. COUNT THE NUMBER OF NODES IN BINARY SEARCH TREE CONSTRUCTED DYNAMICALLY</a> 
                    </div>
                </div></li>
                <li><div class="dropdown">
                    <button class="dropbtn"><a href="#ss">Searching and sorting</a></button>
                    <div class="dropdown-content" style="right: 0;">
                        <a href="#ss1">Linear Search through iteration</a> 
                        <a href="#ss2">Linear Search through recursion</a> 
                        <a href="#ss3">Binary Search through iteration</a> 
                        <a href="#ss4">Binary Search through recursion</a> 
                        <a href="#ss5">Selection Sorting through iteration</a> 
                        <a href="#ss6">Bubble Sorting through iteration</a> 
                        <a href="#ss7">Insertion Sorting through Iteration</a> 
                        <a href="#ss8">Merge Sort through Iteration</a> 
                        <a href="#ss9">Merge Sort through recursion</a> 
                        <a href="#ss10">Quick Sort through Iteration</a> 
                        <a href="#ss11">Quick Sort through recursion</a> 
                        <a href="#ss12">Show all the complexities of the searching algorithms with exact time taken</a> 
                        <a href="#ss13">Show all the complexities of the sorting algorithms with exact time taken</a> 
                        <a href="#ss14">SORT THE STRING USING QUICK SORT</a> 
                        <a href="#ss15">SORT THE STRING USING MERGE SORT</a> 
                    </div>
                </div></li>
            </ul>
        </nav>
    </header>
    
    <div class="front">
        <div class="bio">
            <h1 id="dsa">DSA Assignment</h1>
            <p>Name : Nitin</p>
           <p>Class : BCA 2nd year</p> 
            <p>Roll No.: 4242/22</p>
            <p>Submitted to : Chetan Kumar</p>
            <button class="login">log in</button>
            <button onclick="topFunction()" id="myBtn" title="Go to top"><img src="./icons8-up-arrow-26.png" alt=""></button>
            <script>
                // Get the button
                let mybutton = document.getElementById("myBtn");
                
                // When the user scrolls down 20px from the top of the document, show the button
                window.onscroll = function() {scrollFunction()};
                
                function scrollFunction() {
                  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                    mybutton.style.display = "block";
                  } else {
                    mybutton.style.display = "none";
                  }
                }
                
                // When the user clicks on the button, scroll to the top of the document
                function topFunction() {
                  document.body.scrollTop = 0;
                  document.documentElement.scrollTop = 0;
                }
                </script>
        </div>
        
    </div>
    <main>
        <div class="nav2">
            <div class="logo2">
                <p id="arrays">Arrays</p>
            </div>
            <p id="qcount">Questions=20</p>
        </div>
        <div class="ques">
            
            <div id="arr1">
                <pre>
                <p>Quesion no.1 - Enter an array from user and display all the value ?</p>
                <code>
#include &ltstdio.h>

    int main() {
    int n, i;
                            
    printf("Enter the number of elements: ");
    scanf("%d", &n);
                            
    int arr[n];
                            
    printf("Enter the elements:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
        }
                            
    printf("The elements you entered are: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
        }
    printf("\n");
                            
    return 0;
}
                            
                </code>
                
                <p>Output</p>
                <code>
Enter the number of elements: 5
    Enter the elements:
    Enter element 1: 10
    Enter element 2: 20
    Enter element 3: 30
    Enter element 4: 40
    Enter element 5: 50
    The elements you entered are: 10 20 30 40 50

                </code>
                </pre>
            </div>
            <div class="borderline"></div>
            
            <div id="arr2">
                <pre>
                <p>Quesion No.2 Enter an array from user and print the array in reverse order ?</p>
                    <code>
#include &ltstdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("The array in reverse order is: ");
    for (i = n - 1; i >= 0; i--) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}

                    </code>
                    <p>Output-</p>
                    <code>
Enter the number of elements: 5
Enter the elements:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Enter element 5: 50
The array in reverse order is: 50 40 30 20 10

                    </code>
                </pre>
            </div>
            <div class="borderline"></div>
            <div id="arr3">
                <pre>
                <p>Quesion No. -3 Enter an array from user and copy the array into second array ?
                </p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int firstArray[n], secondArray[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &firstArray[i]);
        secondArray[i] = firstArray[i];
    }

    printf("Elements of the second array (copy): ");
    for (i = 0; i < n; i++) {
        printf("%d ", secondArray[i]);
    }
    printf("\n");

    return 0;
}
           
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 4
Enter the elements of the first array:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Elements of the second array (copy): 10 20 30 40
           
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr4">
                <pre>
                <p>Quesion No. - Enter an array from user and copy it into another array in reverse order ?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int firstArray[n], secondArray[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &firstArray[i]);
    }

    printf("Copying the array in reverse order...\n");
    for (i = 0; i < n; i++) {
        secondArray[i] = firstArray[n - 1 - i];
    }

    printf("Elements of the second array (copy in reverse order): ");
    for (i = 0; i < n; i++) {
        printf("%d ", secondArray[i]);
    }
    printf("\n");

    return 0;
}
           
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 5
Enter the elements of the first array:
Enter element 1: 10
Enter element 2: 20
Enter element 3: 30
Enter element 4: 40
Enter element 5: 50
Copying the array in reverse order...
Elements of the second array (copy in reverse order): 50 40 30 20 10
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr5">
                <pre>
                <p>Quesion No. -5 Enter an array from user and print the number which is even ?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Even numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (arr[i] % 2 == 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 5
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 25
Enter element 3: 12
Enter element 4: 7
Enter element 5: 16
Even numbers in the array are: 10 12 16
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr6">
                <pre>
                <p>Quesion No. -6 Enter an array from user and print the number which is positive ?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Positive numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (arr[i] > 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
                        
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 10
Enter element 2: -5
Enter element 3: 0
Enter element 4: 12
Enter element 5: -8
Enter element 6: 7
Positive numbers in the array are: 10 12 7
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr7">
                <pre>
                <p>Quesion No. -7 Enter an array from user and square all the values of array ?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Square of all values of the array: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i] * arr[i]);
    }
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 4
Enter the elements of the array:
Enter element 1: 5
Enter element 2: -3
Enter element 3: 2
Enter element 4: 8
Square of all values of the array: 25 9 4 64
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr8">
                <pre>
                <p>Quesion No. -8 Enter an array from user and find maximum and minimum value?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i;
    int max, min;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    max = arr[0];
    min = arr[0];

    for (i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
        if (arr[i] < min) {
            min = arr[i];
        }
    }

    printf("Maximum value: %d\n", max);
    printf("Minimum value: %d\n", min);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 5
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 25
Enter element 3: 7
Enter element 4: 14
Enter element 5: 3
Maximum value: 25
Minimum value: 3
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr9">
                <pre>
                <p>Quesion No. -9 Enter an array from user and find the k-th smallest value?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i, k;
    int temp;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Enter the value of k: ");
    scanf("%d", &k);

    // Using bubble sort to sort the array
    for (i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    printf("The %dth smallest value is: %d\n", k, arr[k - 1]);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 10
Enter element 2: 5
Enter element 3: 8
Enter element 4: 3
Enter element 5: 12
Enter element 6: 7
Enter the value of k: 3
The 3th smallest value is: 7
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr10">
                <pre>
                <p>Quesion No. -10 Enter an array from user and add all values ?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i, sum = 0;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
        sum += arr[i];
    }

    printf("Sum of all values in the array: %d\n", sum);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 4
Enter the elements of the array:
Enter element 1: 5
Enter element 2: 10
Enter element 3: 15
Enter element 4: 20
Sum of all values in the array: 50
           
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr11">
                <pre>
                <p>Quesion No. -11 Enter an array from user and find the duplicate values?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i, j;
    int count;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Duplicate values in the array are: ");
    for (i = 0; i < n; i++) {
        count = 0;
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                count++;
                break;
            }
        }
        if (count > 0) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 8
Enter the elements of the array:
Enter element 1: 4
Enter element 2: 2
Enter element 3: 6
Enter element 4: 8
Enter element 5: 2
Enter element 6: 6
Enter element 7: 4
Enter element 8: 10
Duplicate values in the array are: 4 2 6
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr12">
                <pre>
                <p>Quesion No. -12 Enter an array from user and remove the duplicate values and fill with zero?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i, j;
    int count;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    for (i = 0; i < n - 1; i++) {
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                arr[j] = 0;
            }
        }
    }

    printf("Array after removing duplicates and filling with zeros: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 7
Enter the elements of the array:
Enter element 1: 3
Enter element 2: 4
Enter element 3: 5
Enter element 4: 3
Enter element 5: 6
Enter element 6: 4
Enter element 7: 5
Array after removing duplicates and filling with zeros: 3 4 5 0 6 0 0
           
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr13">
                <pre>
                <p>Quesion No. -13 Enter an array from user and count the duplicate values?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, i, j;
    int count, total_count = 0;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    for (i = 0; i < n - 1; i++) {
        count = 0;
        for (j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                count++;
                break;
            }
        }
        if (count > 0) {
            total_count++;
        }
    }

    printf("Total number of duplicate values in the array: %d\n", total_count);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 6
Enter the elements of the array:
Enter element 1: 5
Enter element 2: 3
Enter element 3: 5
Enter element 4: 2
Enter element 5: 7
Enter element 6: 3
Total number of duplicate values in the array: 2
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr14">
                <pre>
                <p>Quesion No. -14 Enter an array from user and print all possible combinations of the elements?</p>
                <code>
#include &ltstdio.h>

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

void generateCombinations(int arr[], int data[], int start, int end, int index, int r) {
    if (index == r) {
        printArray(data, r);
        return;
    }

    for (int i = start; i <= end && end - i + 1 >= r - index; i++) {
        data[index] = arr[i];
        generateCombinations(arr, data, i + 1, end, index + 1, r);
    }
}

int main() {
    int n;
    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the array: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    printf("Printing all combination - \n");
    for (int r = 1; r <= n; r++) {
        int data[r];
        generateCombinations(arr, data, 0, n - 1, 0, r);
    }

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the size of the array: 4
Enter the elements of the array: 1
2
3
4
Printing all combination - 
1 
2 
3
4
1 2
1 3
1 4
2 3
2 4
3 4
1 2 3
1 2 4
1 3 4
2 3 4
1 2 3 4           
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr15">
                <pre>
                <p>Quesion No. -15 Enter an array from user and print all the palindrone numbers?</p>
                <code>
#include &ltstdio.h>

int isPalindrome(int num) {
    int reversed = 0;
    int original = num;

    while (num > 0) {
        int remainder = num % 10;
        reversed = reversed * 10 + remainder;
        num /= 10;
    }

    return original == reversed;
}

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Palindrome numbers in the array are: ");
    for (i = 0; i < n; i++) {
        if (isPalindrome(arr[i])) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements: 5
Enter element 1: 121
Enter element 2: 34
Enter element 3: 1551
Enter element 4: 67
Enter element 5: 12321
Palindrome numbers in the array are: 121 1551 12321
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr16">
                <pre>
                <p>Quesion No. -16 Enter two arrays from the user and check they are same or not?</p>
                <code>
#include &ltstdio.h>
#include &ltstdbool.h>

bool areEqual(int arr1[], int arr2[], int n) {
    for (int i = 0; i < n; i++) {
        if (arr1[i] != arr2[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    int n, i;

    printf("Enter the number of elements in the arrays: ");
    scanf("%d", &n);

    int arr1[n], arr2[n];

    printf("Enter the elements of the first array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr1[i]);
    }

    printf("Enter the elements of the second array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr2[i]);
    }

    if (areEqual(arr1, arr2, n)) {
        printf("The arrays are the same.\n");
    } else {
        printf("The arrays are not the same.\n");
    }

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements in the arrays: 4
Enter the elements of the first array:
Enter element 1: 2
Enter element 2: 5
Enter element 3: 3
Enter element 4: 8
Enter the elements of the second array:
Enter element 1: 2
Enter element 2: 5
Enter element 3: 3
Enter element 4: 8
The arrays are the same.
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr17">
                <pre>
                <p>Quesion No. -17 Merge the two sorted arrays into one array but in sorted order?</p>
                <code>
#include &ltstdio.h>

int main() {
    int n, m, i, j, k;

    printf("Enter the number of elements in the first array: ");
    scanf("%d", &n);

    int arr1[n];

    printf("Enter the elements of the first array in sorted order:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr1[i]);
    }

    printf("Enter the number of elements in the second array: ");
    scanf("%d", &m);

    int arr2[m];

    printf("Enter the elements of the second array in sorted order:\n");
    for (i = 0; i < m; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr2[i]);
    }

    int merged[n + m];
    i = 0,j = 0,k = 0;

    while (i < n && j < m) {
        if (arr1[i] < arr2[j]) {
            merged[k] = arr1[i];
            i++;
        } else {
            merged[k] = arr2[j];
            j++;
        }
        k++;
    }

    while (i < n) {
        merged[k] = arr1[i];
        i++;
        k++;
    }

    while (j < m) {
        merged[k] = arr2[j];
        j++;
        k++;
    }

    printf("Merged array in sorted order: ");
    for (i = 0; i < n + m; i++) {
        printf("%d ", merged[i]);
    }
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements in the first array: 4
Enter the elements of the first array in sorted order:
Enter element 1: 2
Enter element 2: 4
Enter element 3: 6
Enter element 4: 8
Enter the number of elements in the second array: 3
Enter the elements of the second array in sorted order:
Enter element 1: 1
Enter element 2: 3
Enter element 3: 7
Merged array in sorted order: 1 2 3 4 6 7 8
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr18">
                <pre>
                <p>Quesion No. -18 Find the local minima in the array? (An element in an array is a local minima if it less than the element after it, and the element before it)</p>
                <code>
#include &ltstdio.h>

void findLocalMinima(int arr[], int n) {
    if (n == 0) {
        return;
    }

    if (arr[0] < arr[1]) {
        printf("%d ", arr[0]);
    }

    for (int i = 1; i < n - 1; i++) {
        if (arr[i] < arr[i - 1] && arr[i] < arr[i + 1]) {
            printf("%d ", arr[i]);
        }
    }

    if (arr[n - 1] < arr[n - 2]) {
        printf("%d ", arr[n - 1]);
    }
}

int main() {
    int n, i;

    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Local minima in the array: ");
    findLocalMinima(arr, n);
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements in the array: 7
Enter the elements of the array:
Enter element 1: 3
Enter element 2: 2
Enter element 3: 4
Enter element 4: 1
Enter element 5: 6
Enter element 6: 5
Enter element 7: 3
Local minima in the array: 2 1 3
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr19">
                <pre>
                <p>Quesion No. -19 Find the local maxima in the array? (An element in an array is a local maxima if it greater than the element after it, and the element before it)</p>
                <code>
#include &ltstdio.h>

void findLocalMaxima(int arr[], int n) {
    if (n == 0) {
        return;
    }

    if (arr[0] > arr[1]) {
        printf("%d ", arr[0]);
    }

    for (int i = 1; i < n - 1; i++) {
        if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
            printf("%d ", arr[i]);
        }
    }

    if (arr[n - 1] > arr[n - 2]) {
        printf("%d ", arr[n - 1]);
    }
}

int main() {
    int n, i;

    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        printf("Enter element %d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("Local maxima in the array: ");
    findLocalMaxima(arr, n);
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements in the array: 6
Enter the elements of the array:
Enter element 1: 2
Enter element 2: 4
Enter element 3: 3
Enter element 4: 6
Enter element 5: 5
Enter element 6: 1
Local maxima in the array: 4 6 5
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="arr20">
                <pre>
                <p>Quesion No. -20 Trapping Rain Water Problem</p>
                <code>
#include&ltstdio.h>
int capturingraindrops(int arr[],int size){
	int i,j,count=0,max;
	int leftmax[7] ;
	int rightmax[7];

	leftmax[0]=arr[0];
	for(i=1;i&ltsize;i++){
		max=arr[i];
		for(j=i-1;j>=0;j--){
			if(arr[j]>max)
				max=arr[j];
				}
			leftmax[i]=max;

		}
	rightmax[size-1]=arr[size-1];
	for(i=size-2;i>=0;i--){
		max=arr[i];
		for(j=i+1;j&ltsize;j++){
			if(arr[j]>max)
				max=arr[j];
				}
		rightmax[i]=max;

		}
	for(i=1;i&ltsize-1;i++){
		if(leftmax[i]>arr[i] && rightmax[i]>arr[i]){
			if(leftmax[i]>rightmax[i]){
				int x= (rightmax[i]-arr[i]);

				count = count + x;
				}
			else if(rightmax[i]>leftmax[i]){
				int x =  (leftmax[i]-arr[i]);

				count = count + x;
				}

			else{
				int x = leftmax[i]-arr[i];

				count = count + x;      }

			}
}
return count;


}
void main(){
	int arr[10],n;
	printf("Enter how many elements you want to enter.");
	scanf("%d",&n);
    for(int i=0;i&ltn;i++){
		printf("Enter the %d element",i+1);
        scanf("%d",&arr[i]);
    }
	int raindrops;
	raindrops= capturingraindrops(arr,n);
	printf("water drops captured = %d\n",raindrops);
}
            
                </code>
                <p>Output-</p>
                <code>
Enter how many elements you want to enter.5
Enter the 1 element5
Enter the 2 element4
Enter the 3 element2
Enter the 4 element1
Enter the 5 element6
water drops captured = 8            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div class="nav2">
                <div class="logo2">
                    <p id="2Darrays">2D Arrays</p>
                </div>
                <p id="qcount">Questions=06</p>
            </div>
            <div id="2Darr1">
                <pre>
                <p>Quesion No. -1 Enter a matrix of 4 rows and 2 columns from the user display it in matrix format?</p>
                <code>
#include&ltstdio.h>
void main()
{
    int rows=4,cols=2;
    int arr1[rows][cols],arr2[rows][cols],i,j;
    printf("Enter the matrix\n");
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            arr2[i][j]=arr1[i][j];
        }
    }
    printf("Elements in copied array\n");
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            printf("%d ",arr2[i][j]);

        }
        printf("\n");
    }
    
}            
                </code>
                <p>Output-</p>
                <code>
Enter the matrix
Enter element at matrix[0][0]1
Enter element at matrix[0][1]1
Enter element at matrix[1][0]2
Enter element at matrix[1][1]2
Enter element at matrix[2][0]3
Enter element at matrix[2][1]3
Enter element at matrix[3][0]4
Enter element at matrix[3][1]4
Elements in copied array
1 1 
2 2 
3 3 
4 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="2Darr2">
                <pre>
                <p>Quesion No. -2 Enter two Matrices from user, add the matrices and display the answer?</p>
                <code>
#include&ltstdio.h>
void main(){
    int arr1[3][3],arr2[3][3],res[3][3],i,j;
    printf("Enter the first matrix");
    for(i=0;i&lt3;i++){
        for(j=0;j&lt3;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i&lt3;i++){
        for(j=0;j&lt3;j++){
            printf("Enter element at matrix2[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
    for(i=0;i&lt3;i++){
        for(j=0;j&lt3;j++){
            res[i][j]=arr1[i][j]+arr2[i][j];
        }
    }
    for(i=0;i&lt3;i++){
        for(j=0;j&lt3;j++){
            printf("%d  ",res[i][j]);
        }
        printf("\n");
    }
}            
                </code>
                <p>Output-</p>
                <code>
Enter the first matrix
Enter element at matrix1[0][0]: 1
Enter element at matrix1[0][1]: 2
Enter element at matrix1[0][2]: 3
Enter element at matrix1[1][0]: 4
Enter element at matrix1[1][1]: 5
Enter element at matrix1[1][2]: 6
Enter element at matrix1[2][0]: 7
Enter element at matrix1[2][1]: 8
Enter element at matrix1[2][2]: 9
Enter the second matrix
Enter element at matrix2[0][0]: 9
Enter element at matrix2[0][1]: 8
Enter element at matrix2[0][2]: 7
Enter element at matrix2[1][0]: 6
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 4
Enter element at matrix2[2][0]: 3
Enter element at matrix2[2][1]: 2
Enter element at matrix2[2][2]: 1
Resultant matrix after addition is:
10  10  10  
10  10  10  
10  10  10              
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="2Darr3">
                <pre>
                <p>Quesion No. -3 Enter two Matrices from user, subtract the matrices and display the answer?</p>
                <code>
#include&ltstdio.h>
void main(){
    
    int arr1[3][3],arr2[3][3],res[3][3],i,j;
    printf("Enter the first matrix");
    for(i=0;i&lt3;i++){
        for(j=0;j&lt3;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i&lt3;i++){
        for(j=0;j&lt3;j++){
            printf("Enter element at matrix2[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
    for(i=0;i&lt3;i++){
        for(j=0;j&lt3;j++){
            res[i][j]=arr1[i][j]-arr2[i][j];
        }
    }
    for(i=0;i&lt3;i++){
        for(j=0;j&lt3;j++){
            printf("%d  ",res[i][j]);
        }
        printf("\n");
    }
}            
                </code>
                <p>Output-</p>
                <code>
Enter the first matrix:
Enter element at matrix1[0][0]: 4
Enter element at matrix1[0][1]: 6
Enter element at matrix1[0][2]: 8
Enter element at matrix1[1][0]: 2
Enter element at matrix1[1][1]: 3
Enter element at matrix1[1][2]: 5
Enter element at matrix1[2][0]: 9
Enter element at matrix1[2][1]: 7
Enter element at matrix1[2][2]: 1
Enter the second matrix:
Enter element at matrix2[0][0]: 1
Enter element at matrix2[0][1]: 2
Enter element at matrix2[0][2]: 3
Enter element at matrix2[1][0]: 4
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 6
Enter element at matrix2[2][0]: 7
Enter element at matrix2[2][1]: 8
Enter element at matrix2[2][2]: 9
Resultant matrix after subtraction is:
3  4  5  
-2  -2  -1  
2  -1  -8  
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="2Darr4">
                <pre>
                <p>Quesion No. -4 Enter two Matrices from user, multiply the matrices and display the answer?</p>
                <code>
#include&ltstdio.h>
void main(){
int arr1[3][3],arr2[3][3],res[3][3]={0},i,j,k,size;
    printf("Enter the number of rows and columns");
    scanf("%d",&size);
    printf("Enter the first matrix");
    for(i=0;i&ltsize;i++){
        for(j=0;j&ltsize;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    printf("Enter the second matrix");
    for(i=0;i&ltsize;i++){
        for(j=0;j&ltsize;j++){
            printf("Enter element at matrix1[%d][%d]",i,j);
            scanf("%d",&arr2[i][j]);
        }
    }
     for ( i = 0; i &lt size; i++)
    {
        for(j=0;j&ltsize;j++){
           
            for(k=0;k&ltsize;k++){
                res[i][j]+=arr1[i][k] * arr2[k][j];
            }
        }
    }
    printf("Product of matrices\n");
    for(i=0;i&ltsize;i++){
        for(j=0;j&ltsize;j++){
            printf("%d ",res[i][j]);    
        }
        printf("\n");
    }

}            
                </code>
                <p>Output-</p>
                <code>
Enter elements of the first matrix:
Enter element at matrix1[0][0]: 1
Enter element at matrix1[0][1]: 2
Enter element at matrix1[0][2]: 3
Enter element at matrix1[1][0]: 4
Enter element at matrix1[1][1]: 5
Enter element at matrix1[1][2]: 6
Enter element at matrix1[2][0]: 7
Enter element at matrix1[2][1]: 8
Enter element at matrix1[2][2]: 9
Enter elements of the second matrix:
Enter element at matrix2[0][0]: 9
Enter element at matrix2[0][1]: 8
Enter element at matrix2[0][2]: 7
Enter element at matrix2[1][0]: 6
Enter element at matrix2[1][1]: 5
Enter element at matrix2[1][2]: 4
Enter element at matrix2[2][0]: 3
Enter element at matrix2[2][1]: 2
Enter element at matrix2[2][2]: 1
Product of the matrices is:
30  24  18 
84  69  54 
138  114  90 
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="2Darr5">
                <pre>
                <p>Quesion No. -5 Enter a Matrix from user, copy it in another matrix of same size?</p>
                <code>
#include&ltstdio.h>
void main()
{
    int rows,cols;
    printf("Enter the no. of rows");
    scanf("%d",&rows);
    printf("Enter the no. of cols");
    scanf("%d",&cols);
    int arr1[rows][cols],arr2[rows][cols],i,j;
    printf("Enter the matrix");
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            arr2[i][j]=arr1[i][j];
        }
    }
    printf("Elements in copied array\n");
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            printf("%d ",arr2[i][j]);

        }
        printf("\n");
    }
    
}           
                </code>
                <p>Output-</p>
                <code>
Enter the no. of rows2
Enter the no. of cols3
Enter the matrixEnter element at matrix[0][0]1
Enter element at matrix[0][1]2
Enter element at matrix[0][2]3
Enter element at matrix[1][0]4
Enter element at matrix[1][1]5
Enter element at matrix[1][2]6
Elements in copied array
1 2 3 
4 5 6             
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="2Darr6">
                <pre>
                <p>Quesion No. -6 Enter the Matrix from user, multiply it with a scalar value and display the answer?</p>
                <code>
#include&ltstdio.h>
void main(){
    int rows=4,cols=2;
    printf("Enter the number of rows ");
    scanf("%d",&rows);
    printf("Enter the number of columns");
    scanf("%d",&cols);
    int arr1[rows][cols],res[rows][cols],i,j,scalar;
    printf("Enter the scalar value");
    scanf("%d",&scalar);
    printf("Enter the matrix\n");
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            printf("Enter element at matrix[%d][%d]",i,j);
            scanf("%d",&arr1[i][j]);
        }
    }
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            res[i][j]=arr1[i][j]*scalar;
        }
    }
    for(i=0;i&ltrows;i++){
        for(j=0;j&ltcols;j++){
            printf("%d ",res[i][j]);
        }
        printf("\n");
    }
}            
                </code>
                <p>Output-</p>
                <code>
Enter the number of rows 2
Enter the number of columns2
Enter the scalar value3
Enter the matrix
Enter element at matrix[0][0]1
Enter element at matrix[0][1]2
Enter element at matrix[1][0]3
Enter element at matrix[1][1]1
3 6 
9 3             
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div id="2Darr7">
                <pre>
                <p>Quesion No. -7 CREATE A TIC TAC TOE GAME</p>
                <code>
            
                </code>
                <p>Output-</p>
                <code>
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div class="nav2">
                <div class="logo2">
                    <p id="strings">Strings</p>
                </div>
                <p id="qcount">Questions=30</p>
            </div>
            <div id="str1">
                <pre>
                <p>Quesion No. - 1 Convert in uppercase ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
void changeInUpper(char * str,int size){
    for(int i=0;i&ltsize;i++){
        if(str[i]>='a' && str[i]<='z'){
            str[i]=str[i]-32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInUpper(str,strlen(str));
    printf("After changing in Uppercase - %s",str);

}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
hello world
After changing in Uppercase - HELLO WORLD            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str2">
                <pre>
                <p>Quesion No. - 2 Convert into lowercase ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
void changeInLower(char * str,int size){
    for(int i=0;i&ltsize;i++){
        if(str[i]>='A' && str[i]<='Z'){
            str[i]=str[i]+32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInLower(str,strlen(str));
    printf("After changing in lowercase - %s",str);

}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
Hello WORLD
After changing in lowercase - hello world            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str3">
                <pre>
                <p>Quesion No. - 3 Convert into sentence case ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
void changeInSentenceCase(char * str,int size){
    if(str[0]>='a' && str[0]<='z'){
            str[0]=str[0]-32;
        }
    for(int i=1;i&ltsize;i++){
        if(str[i]>='A' && str[i]<='Z'){
            str[i]=str[i]+32;
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInSentenceCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
This is a SentENCE aS INpUT.      
After changing in Sentence case - This is a sentence as input.            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str4">
                <pre>
                <p>Quesion No. - 4 Convert into title case ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
void changeInTitleCase(char * str,int size){
    if(str[0]>='a' && str[0]<='z'){
            str[0]=str[0]-32;
        }
    for(int i=1;i&ltsize;i++){
        if(str[i-1]==' '){
            if(str[i]>='a' && str[i]<='z'){
                str[i]=str[i]-32;
            }
        }
        else{
            if(str[i]>='A' && str[i]<='Z'){
                str[i]=str[i]+32;
            }
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInTitleCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
coVERT thiS to TITLEcase.
After changing in Sentence case - Covert This To Titlecase.            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str5">
                <pre>
                <p>Quesion No. - 5 Convert into toggle case ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
void changeInTitleCase(char * str,int size){
    if(str[0]>='A' && str[0]<='Z'){
            str[0]=str[0]+32;
        }
    for(int i=1;i&ltsize;i++){
        if(str[i-1]==' '){
            if(str[i]>='A' && str[i]<='Z'){
                str[i]=str[i]+32;
            }
        }
        else{
            if(str[i]>='a' && str[i]<='z'){
                str[i]=str[i]-32;
            }
        }
    }
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);
    changeInTitleCase(str,strlen(str));
    printf("After changing in Sentence case - %s",str);

}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
Covert this to toggle case
After changing in Sentence case - cOVERT tHIS tO tOGGLE cASE            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str6">
                <pre>
                <p>Quesion No. - 6 Final length of the string ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
void main(){
    char str[10];
    printf("Enter the string - \n");
    gets(str);   
    printf("Final length of the string is - %d",finalLength(str));

}           
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
hello world
Final length of the string is - 11            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str7">
                <pre>
                <p>Quesion No. - 7 Compare those string ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
int compareString(char * str,char * str2){
    int i=0;
    if(finalLength(str)!=finalLength(str2))
        return 0;
    while(str[i]){
        if(str[i]!=str2[i]){
            return 0;
        }
        i++;
    }
    return 1;
}
void main(){
    char str[20];
    char str2[20];
    printf("Enter the string1 - \n");
    gets(str);   
    printf("Enter the string2 - \n");
    gets(str2);   
    if(compareString(str,str2))
        printf("Strings are equal");
    else
        printf("Strings are not equal");
}           
                </code>
                <p>Output-</p>
                <code>
Enter the string1 - 
hello
Enter the string2 - 
world
Strings are not equal            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str8">
                <pre>
                <p>Quesion No. - 8 Concatenate the string ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstdlib.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
char * concatenateString(char * str,char * str2){
    int size = finalLength(str)+ finalLength(str2);
    char * strcat= (char *)malloc(size * sizeof(char));
    int i=0;
    while(str[i]){
        strcat[i]=str[i];
        i++;
    }
    int j=0;
    while(str2[j]){
        strcat[i]=str2[j];
        j++;
        i++;
    }
    return strcat;
}
void main(){
    char str[20];
    char str2[20];
    char * str3;
    printf("Enter the string1 - \n");
    gets(str);   
    printf("Enter the string2 - \n");
    gets(str2);   
    str3 = concatenateString(str,str2);
    printf("%s",str3);
    free(str3);
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string1 - 
hello 
Enter the string2 -
world
hello world            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str9">
                <pre>
                <p>Quesion No. - 9 Copy that string into another string ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstdlib.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
char * copyString(char * str){
    int size = finalLength(str)+1;
    char * strcopied= (char *)malloc(size * sizeof(char));
    int i=0;
    while(str[i]){
        strcopied[i]=str[i];
        i++;
    }
    strcopied[i]='\0';
    return strcopied;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2 = copyString(str);
    printf("Original string - %s\n",str);
    printf("Copied string - %s",str2);
    free(str2);
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
helloo world 
Original string - helloo world
Copied string - helloo world            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str10">
                <pre>
                <p>Quesion No. - 10 Enter index number and print character on that index ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstdlib.h>

void main(){
    char str[20];
    int index;
    printf("Enter the string - \n");
    gets(str); 
    printf("Enter the index number - \n");
    scanf("%d",&index);
    printf("Character at index %d is %c.",index,str[index]);
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
hello world
Enter the index number -
6
Character at index 6 is w.            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str11">
                <pre>
                <p>Quesion No. - 11 Check its palindrome or not?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
int finalLength(char * str){
    int i=0,len = 0;
    while(str[i]!='\0'){
        len++;
        i++;
    }
    return len;
}
int checkPalindrome(char * str){
    int size = finalLength(str);
    for(int i=0;i<(size+1)/2;i++){
        if(str[i]!=str[size - i -1])
            return 0;
    }
    return 1;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    if(checkPalindrome(str))
        printf("%s is pallindrome.",str);
    else
        printf("%s is not pallindrome.",str);
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
nitin
nitin is pallindrome.            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str12">
                <pre>
                <p>Quesion No. - 12 Print each character in new line ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
#include&ltstdlib.h>
char * printNewlines(char * str){
    int i=0;
    char * str2 = (char *)malloc(strlen(str)*sizeof(char));
    strcpy(str2,str);
    while(str2[i]){
        if(str2[i]==' ')
            str2[i]='\n';
        i++;
    }
    return str2;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2= printNewlines(str);
    printf("%s",str2);
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
this is a string
this
is
a
string            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str13">
                <pre>
                <p>Quesion No. - 13 Copy reverse order into another string ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
#include&ltstdlib.h>
char * copyReverse(char * str){
    int i= strlen(str) - 1,j=0;
    char * str2 = (char *)malloc(strlen(str)*sizeof(char));
    for(;i>=0;i--){
        str2[j++]= str[i];
    }
    str2[j]='\0';
    return str2;
}
void main(){
    char str[20];
    char * str2;
    printf("Enter the string - \n");
    gets(str);    
    str2= copyReverse(str);
    printf("%s",str2);
    free(str2);
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
hello world
dlrow olleh            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str14">
                <pre>
                <p>Quesion No. - 14 2 strings and print difference each character ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
#include&ltstdlib.h>
int * diffOfAsciiValues(char * str1,char * str2){
    if(strlen(str1)!=strlen(str2))
        return NULL;
    int size= strlen(str1) + strlen(str2);
    int * str = (int *)malloc(size*sizeof(int));
    for(int i=0;i&ltstrlen(str1);i++){
        str[i]= str1[i] - str2[i];
    }
    return str;
}
void main(){
    char str1[20];
    char str2[20];
    int * str;
    printf("Enter the string1 - \n");
    gets(str1);    
    printf("Enter the string2 - \n");
    gets(str2);    
    str= diffOfAsciiValues(str1,str2);
    for(int i=0;i&ltstrlen(str1);i++){
        printf("%d ",str[i]);
    }
    free(str);
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string1 - 
hello
Enter the string2 - 
world
-15 -10 -6 0 11            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str15">
                <pre>
                <p>Quesion No. - 15 Enter a character , it is exist or not ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
#include&ltstdlib.h>
int findChar(char * str1,char x){
    int i=0;
    while(str1[i]){
        if(str1[i]==x)
            return i+1;
            i++;
    }
    return 0;
}
void main(){
    char str1[20];
    char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("Enter the character - \n");
    scanf("%c",&str2);   
    int pos = findChar(str1,str2);
    if(pos)
        printf("%c is present at position %d",str2,pos);
    else
        printf("%c is not found");
        
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
hello world
Enter the character -
o
o is present at position 5            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str16">
                <pre>
                <p>Quesion No. - 16 Enter a character if it is exist then print the bound number ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
#include&ltstdlib.h>
int findChar(char * str1,char x){
    int i=0;
    while(str1[i]){
        if(str1[i]==x)
            return i+1;
            i++;
    }
    return -1;
}
void main(){
    char str1[20];
    char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("Enter the character - \n");
    scanf("%c",&str2);   
    int pos = findChar(str1,str2);
    if(pos!=-1)
        printf("%c is present at index %d",str2,pos);
    else
        printf("%d",pos);
        
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
Hello world.
Enter the character - 
d
d is present at index 11            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str17">
                <pre>
                <p>Quesion No. - 17 Count all vowels ?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
#include&ltstdlib.h>
int countVowels(char * str1){
    int i=0,count=0;
    while(str1[i]){
        if(str1[i]=='a'||str1[i]=='e'||str1[i]=='i'||str1[i]=='o'||str1[i]=='u'||str1[i]=='A'||str1[i]=='E'||str1[i]=='I'||str1[i]=='O'||str1[i]=='U')
            count++;
            i++;
    }
    return count;
}
void main(){
    char str1[20];char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("No. of vowels = %d",countVowels(str1));  
    
        
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
THis is a sentence. 
No. of vowels = 6            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str18">
                <pre>
                <p>Quesion No. - 18 Convert into integer?
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
void printStringInInt(char * arr){
    int i=0;
while(arr[i]){
    printf("%d ",arr[i++]);
}
}

void main(){
    char str[30]; 
    printf("Enter the string.\n");
    gets(str);
    printStringInInt(str);
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the string.
this is a string.
116 104 105 115 32 105 115 32 97 32 115 116 114 105 110 103 46            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <!-- <div id="str19">
                <pre>
                <p>Quesion No. - 19 Convert into float?
                </p>
                <code>
            
                </code>
                <p>Output-</p>
                <code>
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>  -->
             
            <div id="str21">
                <pre>
                <p>Quesion No. - 20 Count the number of characters, words, spaces and lines.
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
#include&ltstdlib.h>
int countchar(char * str1){
    int i=0,countchar=0;
    while(str1[i]){
        if(str1[i]>='a' && str1[i]<='z'|| str1[i]>='A'&& str1[i]<='Z')
            countchar++;
    i++;
    }
    return countchar;
}
int countspaces(char * str1){
    int i=0,spaces=0;
    while(str1[i]){
        if(str1[i]==' ')
            spaces++;
    i++;
    }
    return spaces;
}
int countlines(char * str1){
    int i=0,countlines=0;
    while(str1[i]){
        if(str1[i]=='.')
            countlines++;
    i++;
    }
    return countlines;
}
void main(){
    char str1[20];char str2;
    printf("Enter the string - \n");
    gets(str1);    
    printf("No. of character = %d\n",countchar(str1));  
    printf("No. of words = %d\n",countspaces(str1)+1);  
    printf("No. of spaces = %d\n",countspaces(str1));  
    printf("No. of lines = %d\n",countlines(str1));          
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string - 
This is first line.This is second line. 
No. of character = 31
No. of words = 7
No. of spaces = 6
No. of lines = 2            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str22">
                <pre>
                <p>Quesion No. - 21 Print all the possiblities of a string i.e. "abcde".
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>

void swap(char *x, char *y) {
    char temp = *x;
    *x = *y;
    *y = temp;
}

void permute(char *str, int l, int r) {
    if (l == r) {
        printf("%s\n", str);
    } else {
        for (int i = l; i <= r; i++) {
            swap((str + l), (str + i));
            permute(str, l + 1, r);
            swap((str + l), (str + i)); 
        }
    }
}

int main() {
    char str[] = "abcde";
    int n = strlen(str);
    printf("Printing all combinations-\n");
    permute(str, 0, n - 1);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Printing all combinations-
abcde
abced
abdce
abdec
abedc
abecd
acbde
acbed
acdbe
acdeb
acedb
acebd
adcbe
adceb
adbce
adbec
adebc
adecb
aecdb
aecbd
aedcb
aedbc
aebdc
aebcd
bacde
baced
badce
badec
baedc
baecd
bcade
bcaed
bcdae
bcdea
bceda
bcead
bdcae
bdcea
bdace
bdaec
bdeac
bdeca
becda
becad
bedca
bedac
beadc
beacd
cbade
cbaed
cbdae
cbdea
cbeda
cbead
cabde
cabed
cadbe
cadeb
caedb
caebd
cdabe
cdaeb
cdbae
cdbea
cdeba
cdeab
ceadb
ceabd
cedab
cedba
cebda
cebad
dbcae
dbcea
dbace
dbaec
dbeac
dbeca
dcbae
dcbea
dcabe
dcaeb
dceab
dceba
dacbe
daceb
dabce
dabec
daebc
daecb
decab
decba
deacb
deabc
debac
debca
ebcda
ebcad
ebdca
ebdac
ebadc
ebacd
ecbda
ecbad
ecdba
ecdab
ecadb
ecabd
edcba
edcab
edbca
edbac
edabc
edacb
eacdb
eacbd
eadcb
eadbc
eabdc
eabcd            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str23">
                <pre>
                <p>Quesion No. - 22 Sort the string in ascending order.
                </p>
                <code>
#include&ltstdio.h>
#include&ltstring.h>
char * sortString( char * arr){
        int size = strlen(arr);
        int i,j;
        char temp;
        for(i=0;i&ltsize;i++){
            for(j=0;j&ltsize - i -1;j++){
                if(arr[j]>arr[j+1]){
                    temp = arr[j];
                    arr[j]= arr[j+1];
                    arr[j+1] = temp; 
                }
            }
        }
return arr;
}
void main(){
    char str[50];
    printf("Enter the string.\n");
    gets(str);
    int i=0;
    char * str1 = sortString(str);
    while(i&ltstrlen(str1)){
        if(str1[i]!=' ' && str1[i]!='.')
            printf("%c ",str1[i]);
        i++;
    }
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string.
hello world.this is a string.
a d e g h h i i i l l l n o o r r s s s t t w             
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str24">
                <pre>
                <p>Quesion No. - 23 Enter a sentence from user and then enter the word and count the occurence of that word in the sentence.
                </p>
                <code>
#include&ltstdio.h>

int countOccurence(char * arr,char * word){
    int i=0,count =0;
    while(arr[i]){
        int j =0,flag=1;
        while(arr[i]!=' '&& arr[i]!='.'){
            if(arr[i]==word[j]){
                i++;
                j++;
            }
            else{
                flag =0;
                while(arr[i]!=' '&& arr[i]!='.'){
                    i++;
                }
            }
        }
        if(flag==1)
            count++;
    
    i++;
    }
    
return count;
}
void main(){
    char str[30];
    char word[15];
    printf("Enter the string");
    gets(str);
    printf("Enter the word");
    gets(word);
    printf("%s occurs %d times",word, countOccurence(str,word));
}            
                </code>
                <p>Output-</p>
                <code>
Enter the string
This is a word that is - is. 
Enter the word
is
is occurs 3 times            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str25">
                <pre>
                <p>Quesion No. - 24 Enter a sentence from user and then enter the word and replace that word by another word.
                </p>
                <code>
#include&ltstdio.h>
#include&ltstblib.h>
#include&ltstring.h>
char * replaceWord(char * arr,char * word,char * replacingword){
    int i=0,count =0,k;
    int newsize = strlen(arr)+strlen(replacingword);
    int initial;
    char * newarr = (char *)malloc(newsize*sizeof(char));
    while(arr[i]){
        int j =0,flag=1;
        while(arr[i]!=' '&& arr[i]!='.'){
            initial = i-1;
            if(arr[i]==word[j]){
                i++;
                j++;
            }
            else{
                flag =0;
                while(arr[i]!=' '&& arr[i]!='.'){
                    i++;
                    initial = -1;
                }
            }
        }
        if(flag==1){
            i =j=k  = 0;
            while(arr[i]){
                if(i!=initial){
                    newarr[j] = arr[i];
                    i++;
                    j++;
                }
                else{
                    while(replacingword[k]){
                        newarr[j]=replacingword[k];
                        k++;
                        j++;
                    }
                    while(arr[i]!=' ' && arr[i]!='.'){
                        i++;
                    }
                }
            }
        }
    
    i++;
    }
    
return newarr;
}
void main(){
    char str[30];
    char word[15];
    char replaceby[15];
    printf("Enter the string");
    gets(str);
    printf("Enter the  word to replace");
    gets(word);
    printf("Enter the word by which word will be replaced. ");
    gets(replaceby);
    char * new;
    new = replaceWord(str,word,replaceby);
    printf("%s",new);
}             
                </code>
                <p>Output-</p>
                <code>
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str26">
                <pre>
                <p>Quesion No. - 25 Trim the spaces from both ends (if any)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>

char *trimString(char *str) {
    int i = 0, j = strlen(str) - 1;

    while (str[i] == ' ') {
        i++;
    }

    while (j > i && str[j] == ' ') {
        j--;
    }

    for (int k = 0; k <= j - i; k++) {
        str[k] = str[i + k];
    }

    str[j - i + 1] = '\0';
    return str;
}

int main() {
    char str[100];
    printf("Enter a string: ");
    gets(str);

    char *trimmedString = trimString(str);
    printf("Trimmed string: %s\n", trimmedString);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter a string:            this is a string
Trimmed string: this is a string            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str27">
                <pre>
                <p>Quesion No. - 26  ENTER THE STRING FROM USER AND SPLITS THE FIRST WORD AND SECOND WORD AND RETURN THE START INDEX OF THE SECOND WORD.
                </p>
                <code>
            
                </code>
                <p>Output-</p>
                <code>
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str28">
                <pre>
                <p>Quesion No. - 27 Display the string with text alignment option (1 for left, 2 for center, 3 right)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>

int split(char *str, char *firstWord, char *secondWord) {
    int i, j = 0, startIndexOfSecond = -1;
    int len = strlen(str);

    for (i = 0; i < len && str[i] != ' ' && str[i] != '\t' && str[i] != '\n'; i++) {
        firstWord[i] = str[i];
    }
    firstWord[i] = '\0';

    while (i < len && (str[i] == ' ' || str[i] == '\t' || str[i] == '\n')) {
        i++;
    }

    startIndexOfSecond = i;
    for (; i < len; i++) {
        secondWord[j++] = str[i];
    }
    secondWord[j] = '\0';

    return startIndexOfSecond;
}

int main() {
    char str[100], firstWord[50], secondWord[50];
    printf("Enter a string: ");
    fgets(str, sizeof(str), stdin);

    int startIndexOfSecond = split(str, firstWord, secondWord);

    printf("First word: %s\n", firstWord);
    printf("Second word: %s\n", secondWord);
    printf("Start index of the second word: %d\n", startIndexOfSecond);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter a string: hello world
First word: hello
Second word: world

Start index of the second word: 6            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str29">
                <pre>
                <p>Quesion No. - 28 Create a dictionary having 10 words and their meaning with following operations. [create, delete,search]
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>

#define SIZE 10

struct Dictionary {
    char word[20];
    char meaning[100];
};

void create(struct Dictionary dict[], int *count) {
    if (*count >= SIZE) {
        printf("Dictionary is full. Cannot add more words.\n");
        return;
    }

    printf("Enter word: ");
    scanf("%s", dict[*count].word);

    printf("Enter meaning: ");
    scanf(" %[^\n]s", dict[*count].meaning);

    (*count)++;
}

void search(struct Dictionary dict[], int count, char *word) {
    int found = 0;
    for (int i = 0; i < count; i++) {
        if (strcmp(dict[i].word, word) == 0) {
            printf("Meaning: %s\n", dict[i].meaning);
            found = 1;
            break;
        }
    }
    if (!found) {
        printf("Word not found in the dictionary.\n");
    }
}

void delete (struct Dictionary dict[], int *count, char *word) {
    for (int i = 0; i < *count; i++) {
        if (strcmp(dict[i].word, word) == 0) {
            for (int j = i; j < *count - 1; j++) {
                strcpy(dict[j].word, dict[j + 1].word);
                strcpy(dict[j].meaning, dict[j + 1].meaning);
            }
            (*count)--;
            printf("Word deleted from the dictionary.\n");
            return;
        }
    }
    printf("Word not found in the dictionary.\n");
}

int main() {
    struct Dictionary dict[SIZE];
    int count = 0;
    int choice;
    char word[20];

    while (1) {
        printf("\n1. Create\n2. Delete\n3. Search\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                create(dict, &count);
                break;
            case 2:
                printf("Enter word to delete: ");
                scanf("%s", word);
                delete(dict, &count, word);
                break;
            case 3:
                printf("Enter word to search: ");
                scanf("%s", word);
                search(dict, count, word);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 1
Enter word: apple
Enter meaning: A fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 1
Enter word: orange
Enter meaning: A citrus fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 3
Enter word to search: apple
Meaning: A fruit

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 2
Enter word to delete: orange
Word deleted from the dictionary.

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 3
Enter word to search: orange
Word not found in the dictionary.

1. Create
2. Delete
3. Search
4. Exit
Enter your choice: 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="str30">
                <pre>
                <p>Quesion No. -29  Convert characters into string. [for example take 10 characters]
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>

int main() {
    char str[100];
    int asciiValues[100];
    int i, length;

    printf("Enter a string: ");
    fgets(str, sizeof(str), stdin);

    length = strlen(str);

    for (i = 0; i < length - 1; i++) {
        asciiValues[i] = (int)str[i];
    }

    printf("ASCII values of the characters: ");
    for (i = 0; i < length - 1; i++) {
        printf("%d ", asciiValues[i]);
    }
    printf("\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter a string: Hello, world!
ASCII values of characters: 72 101 108 108 111 44 32 119 111 114 108 100 33
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div class="nav2">
                <div class="logo2">
                    <p id="stacks">Stacks</p>
                </div>
                <p id="qcount">Questions=14</p>
            </div>
            <div id="stk1">
                <pre>
                <p>Quesion No. - 1 Implement the operations of stack in an integer array (push, pop, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>

const int MAX_SIZE = 5;

struct Stack {
    int items[5];
    int top;
};

int isEmpty(struct Stack *stack) {
    return stack->top == -1;
}

int isFull(struct Stack *stack) {
    return stack->top == MAX_SIZE - 1;
}

void push(struct Stack *stack, int value) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
        printf("%d pushed to the stack.\n", value);
    }
}

int pop(struct Stack *stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int item = stack->items[stack->top];
        stack->top--;
        return item;
    }
}

int peek(struct Stack *stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return -1;
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack stack;
    stack.top = -1;

    int choice, value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(&stack, value);
                break;
            case 2:
                printf("%d popped from the stack\n", pop(&stack));
                break;
            case 3:
                printf("Top element is %d\n", peek(&stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}
            
                </code>
                <p>Output-</p>
                <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 10
10 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 20
20 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is 20

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
20 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
10 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Stack is empty.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk2">
                <pre>
                <p>Quesion No. - 2 Implement the operations of stack in an string array (push, pop, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdbool.h>

#define MAX_SIZE 5

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

bool isFull(struct Stack* stack) {
    return stack->top == MAX_SIZE - 1;
}

bool isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

void push(struct Stack* stack, char value) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
        printf("%c pushed to the stack.\n", value);
    }
}

char pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

char peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return '\0';
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack stack;
    initializeStack(&stack);

    int choice;
    char value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter character to push: ");
                scanf(" %c", &value);
                push(&stack, value);
                break;
            case 2:
                printf("%c popped from the stack.\n", pop(&stack));
                break;
            case 3:
                printf("Top element is %c\n", peek(&stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}
            
                </code>
                <p>Output-</p>
                <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: a
a pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: b
b pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter character to push: c
c pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is c

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
c popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
b popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is a

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk3">
                <pre>
                <p>Quesion No. - 3 Reverse of string using stack
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>
#define MAX_SIZE 50

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

void reverseString(char* str) {
    struct Stack stack;
    initializeStack(&stack);

    int i;
    for (i = 0; str[i] != '\0'; i++) {
        push(&stack, str[i]);
    }

    for (i = 0; stack.top != -1; i++) {
        str[i] = pop(&stack);
    }
}

int main() {
    char str[MAX_SIZE];

    printf("Enter a string: ");
    gets(str);

    printf("Original string: %s\n", str);
    reverseString(str);
    printf("Reversed string: %s\n", str);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter a string: Hello, world!
Original string: Hello, world!
Reversed string: !dlrow ,olleH
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk4">
                <pre>
                <p>Quesion No. - 4 Single bracket matching using stack
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdbool.h>
#define MAX_SIZE 50

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

bool isMatchingPair(char character1, char character2) {
    if (character1 == '(' && character2 == ')')
        return true;
    else if (character1 == '{' && character2 == '}')
        return true;
    else if (character1 == '[' && character2 == ']')
        return true;
    else
        return false;
}

bool checkBalanced(char exp[]) {
    struct Stack stack;
    initializeStack(&stack);

    for (int i = 0; exp[i] != '\0'; i++) {
        if (exp[i] == '(' || exp[i] == '{' || exp[i] == '[')
            push(&stack, exp[i]);
        else if (exp[i] == ')' || exp[i] == '}' || exp[i] == ']') {
            if (stack.top == -1 || !isMatchingPair(stack.items[stack.top], exp[i]))
                return false;
            else
                pop(&stack);
        }
    }
    return stack.top == -1; // Stack should be empty for balanced expression
}

int main() {
    char expression[MAX_SIZE];

    printf("Enter an expression: ");
    gets(expression);

    if (checkBalanced(expression))
        printf("The expression is balanced.\n");
    else
        printf("The expression is not balanced.\n");

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter an expression: (a+b)*[c+d]
The expression is balanced.

Enter an expression: {a+(b*c]+d}
The expression is not balanced.
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk5">
                <pre>
                <p>Quesion No. - 5 Convert the expression into infix to prefix
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>
#include &ltstdbool.h>
#include &ltstdlib.h>

#define MAX_SIZE 100

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int getPrecedence(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
    }
    return -1;
}

bool isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^');
}

bool isOperand(char ch) {
    return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));
}

void infixToPrefix(char* infix, char* prefix) {
    struct Stack stack;
    initializeStack(&stack);
    int i, j = 0;

    for (i = strlen(infix) - 1; i >= 0; i--) {
        if (infix[i] == ')') {
            push(&stack, infix[i]);
        } else if (infix[i] == '(') {
            while (stack.items[stack.top] != ')') {
                prefix[j++] = pop(&stack);
            }
            pop(&stack);  // pop the ')'
        } else if (isOperand(infix[i])) {
            prefix[j++] = infix[i];
        } else if (isOperator(infix[i])) {
            while (getPrecedence(infix[i]) <= getPrecedence(stack.items[stack.top]) && stack.top != -1) {
                prefix[j++] = pop(&stack);
            }
            push(&stack, infix[i]);
        }
    }

    while (stack.top != -1) {
        prefix[j++] = pop(&stack);
    }

    prefix[j] = '\0';
    // Reverse the prefix expression
    int len = strlen(prefix);
    for (i = 0; i < len / 2; i++) {
        char temp = prefix[i];
        prefix[i] = prefix[len - i - 1];
        prefix[len - i - 1] = temp;
    }
}

int main() {
    char infix[MAX_SIZE], prefix[MAX_SIZE];
    printf("Enter an infix expression: ");
    gets(infix);

    infixToPrefix(infix, prefix);
    printf("Prefix expression: %s\n", prefix);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter an infix expression: (A+B)*C-D*E
Prefix expression: -*+ABC*DE
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk6">
                <pre>
                <p>Quesion No. - 6 Convert the expression into infix to postfix
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>
#include &ltstdlib.h>
#include &ltstdbool.h>

#define MAX_SIZE 100

struct Stack {
    char items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, char value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return '\0';
    } else {
        char value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int getPrecedence(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
    }
    return -1;
}

bool isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^');
}

bool isOperand(char ch) {
    return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));
}

void infixToPostfix(char* infix, char* postfix) {
    struct Stack stack;
    initializeStack(&stack);
    int i, j = 0;

    for (i = 0; infix[i] != '\0'; i++) {
        if (isOperand(infix[i])) {
            postfix[j++] = infix[i];
        } else if (infix[i] == '(') {
            push(&stack, infix[i]);
        } else if (infix[i] == ')') {
            while (stack.items[stack.top] != '(') {
                postfix[j++] = pop(&stack);
            }
            pop(&stack);  // Pop the '('
        } else if (isOperator(infix[i])) {
            while (stack.top != -1 && getPrecedence(infix[i]) <= getPrecedence(stack.items[stack.top])) {
                postfix[j++] = pop(&stack);
            }
            push(&stack, infix[i]);
        }
    }

    while (stack.top != -1) {
        postfix[j++] = pop(&stack);
    }

    postfix[j] = '\0';
}

int main() {
    char infix[MAX_SIZE], postfix[MAX_SIZE];
    printf("Enter an infix expression: ");
    fgets(infix);

    infixToPostfix(infix, postfix);
    printf("Postfix expression: %s\n", postfix);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter an infix expression: A+B*C-(D+E)/F
Postfix expression: ABC*+DE+F/-
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk7">
                <pre>
                <p>Quesion No. - 7 Evaluate the prefix expression
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>
#include &ltctype.h>

#define MAX_SIZE 100

struct Stack {
    int items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

int pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int evaluatePrefix(char* expression) {
    struct Stack stack;
    initializeStack(&stack);
    int length = strlen(expression);

    for (int i = length - 1; i >= 0; i--) {
        if (isdigit(expression[i])) {
            push(&stack, expression[i] - '0');
        } else {
            int operand1 = pop(&stack);
            int operand2 = pop(&stack);
            switch (expression[i]) {
                case '+':
                    push(&stack, operand1 + operand2);
                    break;
                case '-':
                    push(&stack, operand1 - operand2);
                    break;
                case '*':
                    push(&stack, operand1 * operand2);
                    break;
                case '/':
                    push(&stack, operand1 / operand2);
                    break;
            }
        }
    }

    return pop(&stack);
}

int main() {
    char expression[MAX_SIZE];
    printf("Enter a prefix expression: ");
    fgets(expression);

    int result = evaluatePrefix(expression);
    printf("Result: %d\n", result);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter a prefix expression: -+7*45+20
Result: 25
           
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk8">
                <pre>
                <p>Quesion No. - 8 Evaluate the postfix expression
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>
#include &ltctype.h>

#define MAX_SIZE 100

struct Stack {
    int items[MAX_SIZE];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

void push(struct Stack* stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = value;
    }
}

int pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    } else {
        int value = stack->items[stack->top];
        stack->top--;
        return value;
    }
}

int evaluatePostfix(char* expression) {
    struct Stack stack;
    initializeStack(&stack);
    int length = strlen(expression);

    for (int i = 0; i < length; i++) {
        if (isdigit(expression[i])) {
            push(&stack, expression[i] - '0');
        } else {
            int operand2 = pop(&stack);
            int operand1 = pop(&stack);
            switch (expression[i]) {
                case '+':
                    push(&stack, operand1 + operand2);
                    break;
                case '-':
                    push(&stack, operand1 - operand2);
                    break;
                case '*':
                    push(&stack, operand1 * operand2);
                    break;
                case '/':
                    push(&stack, operand1 / operand2);
                    break;
            }
        }
    }

    return pop(&stack);
}

int main() {
    char expression[MAX_SIZE];
    printf("Enter a postfix expression: ");
    fgets(expression);

    int result = evaluatePostfix(expression);
    printf("Result: %d\n", result);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter a postfix expression: 345*+2+
Result: 17
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk9">
                <pre>
                <p>Quesion No. - 9 Implement the tower of hanoi
                </p>
                <code>
#include &ltstdio.h>

void towerOfHanoi(int n, char source, char auxiliary, char destination) {
    if (n == 1) {
        printf("Move disk 1 from %c to %c\n", source, destination);
        return;
    }
    towerOfHanoi(n - 1, source, destination, auxiliary);
    printf("Move disk %d from %c to %c\n", n, source, destination);
    towerOfHanoi(n - 1, auxiliary, source, destination);
}

int main() {
    int n = 3; // Number of disks
    towerOfHanoi(n, 'A', 'B', 'C');  // A, B, C are the names of the rods
    return 0;
}
           
                </code>
                <p>Output-</p>
                <code>
Move disk 1 from A to C
Move disk 2 from A to B
Move disk 1 from C to B
Move disk 3 from A to C
Move disk 1 from B to A
Move disk 2 from B to C
Move disk 1 from A to C
           
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk10">
                <pre>
                <p>Quesion No. - 10 Application of recursion using stack
                </p>
                <code>
            
                </code>
                <p>Output-</p>
                <code>
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk11">
                <pre>
                <p>Quesion No. - 11 CREATE TWO INTEGER STACKS IN A SINGLE ARRAY
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

#define MAX_SIZE 10

struct TwoStacks {
    int* array;
    int top1;
    int top2;
    int capacity;
};

struct TwoStacks* createTwoStacks() {
    struct TwoStacks* twoStacks = (struct TwoStacks*)malloc(sizeof(struct TwoStacks));
    if (!twoStacks) {
        return NULL;
    }
    twoStacks->capacity = MAX_SIZE;
    twoStacks->array = (int*)malloc(twoStacks->capacity * sizeof(int));
    if (!twoStacks->array) {
        return NULL;
    }
    twoStacks->top1 = -1;
    twoStacks->top2 = twoStacks->capacity;
    return twoStacks;
}

int isFull(struct TwoStacks* twoStacks) {
    return twoStacks->top1 + 1 == twoStacks->top2;
}

int isEmpty1(struct TwoStacks* twoStacks) {
    return twoStacks->top1 == -1;
}

int isEmpty2(struct TwoStacks* twoStacks) {
    return twoStacks->top2 == twoStacks->capacity;
}

void push1(struct TwoStacks* twoStacks, int value) {
    if (isFull(twoStacks)) {
        printf("Stack Overflow\n");
        return;
    }
    twoStacks->array[++twoStacks->top1] = value;
}

void push2(struct TwoStacks* twoStacks, int value) {
    if (isFull(twoStacks)) {
        printf("Stack Overflow\n");
        return;
    }
    twoStacks->array[--twoStacks->top2] = value;
}

int pop1(struct TwoStacks* twoStacks) {
    if (isEmpty1(twoStacks)) {
        printf("Stack Underflow\n");
        return -1;
    }
    return twoStacks->array[twoStacks->top1--];
}

int pop2(struct TwoStacks* twoStacks) {
    if (isEmpty2(twoStacks)) {
        printf("Stack Underflow\n");
        return -1;
    }
    return twoStacks->array[twoStacks->top2++];
}

int main() {
    struct TwoStacks* twoStacks = createTwoStacks();
    int choice, value;

    do {
        printf("\n1. Push to Stack 1");
        printf("\n2. Push to Stack 2");
        printf("\n3. Pop from Stack 1");
        printf("\n4. Pop from Stack 2");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push to Stack 1: ");
                scanf("%d", &value);
                push1(twoStacks, value);
                break;
            case 2:
                printf("Enter value to push to Stack 2: ");
                scanf("%d", &value);
                push2(twoStacks, value);
                break;
            case 3:
                printf("Popped element from Stack 1: %d\n", pop1(twoStacks));
                break;
            case 4:
                printf("Popped element from Stack 2: %d\n", pop2(twoStacks));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(twoStacks->array);
    free(twoStacks);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 1
Enter value to push to Stack 1: 5

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 2
Enter value to push to Stack 2: 10

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 3
Popped element from Stack 1: 5

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 4
Popped element from Stack 2: 10

1. Push to Stack 1
2. Push to Stack 2
3. Pop from Stack 1
4. Pop from Stack 2
0. Exit
Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk12">
                <pre>
                <p>Quesion No. - 12 Implement the operations of stack dynamically of integers (push, pop, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstdbool.h>

struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    struct Node* top;
    int size;
    int capacity;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->top = NULL;
    stack->size = 0;
    stack->capacity = capacity;
    return stack;
}

bool isFull(struct Stack* stack) {
    return stack->size == stack->capacity;
}

bool isEmpty(struct Stack* stack) {
    return stack->size == 0;
}

void push(struct Stack* stack, int data) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
        return;
    }

    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return -1;
    }

    int data = stack->top->data;
    struct Node* temp = stack->top;
    stack->top = stack->top->next;
    free(temp);
    stack->size--;
    return data;
}

int peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return -1;
    }
    return stack->top->data;
}

int main() {
    struct Stack* stack = createStack(5);
    int choice, value;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(stack, value);
                break;
            case 2:
                printf("%d popped from the stack\n", pop(stack));
                break;
            case 3:
                printf("Top element is %d\n", peek(stack));
                break;
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}
            
                </code>
                <p>Output-</p>
                <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 10
10 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter value to push: 20
20 pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is 20

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
20 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
10 popped from the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Stack is empty.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk13">
                <pre>
                <p>Quesion No. - 13 Implement the operations of stack dynamically of string (push, pop, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>
#include &ltstdbool.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Stack {
    char** items;
    int top;
    int size;
};

struct Stack* createStack(int size) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->items = (char**)malloc(size * sizeof(char*));
    stack->top = -1;
    stack->size = size;
    return stack;
}

bool isFull(struct Stack* stack) {
    return stack->top == stack->size - 1;
}

bool isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

void push(struct Stack* stack, char* str) {
    if (isFull(stack)) {
        printf("Stack is full. Cannot push more elements.\n");
    } else {
        stack->top++;
        stack->items[stack->top] = (char*)malloc(MAX_LENGTH * sizeof(char));
        strcpy(stack->items[stack->top], str);
        printf("%s pushed to the stack.\n", str);
    }
}

char* pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop more elements.\n");
        return NULL;
    } else {
        return stack->items[stack->top--];
    }
}

char* peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return NULL;
    } else {
        return stack->items[stack->top];
    }
}

int main() {
    struct Stack* stack = createStack(MAX_SIZE);
    int choice;
    char str[MAX_LENGTH];

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter string to push: ");
                scanf("%s", str);
                push(stack, str);
                break;
            case 2: {
                char* popped = pop(stack);
                if (popped != NULL) {
                    printf("%s popped from the stack\n", popped);
                }
                break;
            }
            case 3: {
                char* top = peek(stack);
                if (top != NULL) {
                    printf("Top element is %s\n", top);
                }
                break;
            }
            case 4:
                return 0;
            default:
                printf("Invalid choice! Please select a valid option.\n");
        }
    }
}
            
                </code>
                <p>Output-</p>
                <code>
1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: apple
apple pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: banana
banana pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 1
Enter string to push: cherry
cherry pushed to the stack.

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is cherry

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
cherry popped from the stack

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 2
banana popped from the stack

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 3
Top element is apple

1. Push
2. Pop
3. Peek
4. Exit
Enter your choice: 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="stk14">
                <pre>
                <p>Quesion No. - 14 Sort the stack using recursion
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

struct Stack {
    int data;
    struct Stack* next;
};

void initialize(struct Stack** stack) {
    *stack = NULL;
}

int isEmpty(struct Stack* stack) {
    return (stack == NULL);
}

void push(struct Stack** stack, int data) {
    struct Stack* newNode = (struct Stack*)malloc(sizeof(struct Stack));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        return;
    }
    newNode->data = data;
    newNode->next = *stack;
    *stack = newNode;
}

int pop(struct Stack** stack) {
    if (isEmpty(*stack)) {
        printf("Stack is empty\n");
        return -1;
    }
    int data = (*stack)->data;
    struct Stack* temp = *stack;
    *stack = (*stack)->next;
    free(temp);
    return data;
}

void sortedInsert(struct Stack** stack, int element) {
    if (isEmpty(*stack) || element > (*stack)->data) {
        push(stack, element);
        return;
    }

    int temp = pop(stack);
    sortedInsert(stack, element);
    push(stack, temp);
}

void sortStack(struct Stack** stack) {
    if (!isEmpty(*stack)) {
        int temp = pop(stack);
        sortStack(stack);
        sortedInsert(stack, temp);
    }
}

void printStack(struct Stack* stack) {
    while (stack != NULL) {
        printf("%d ", stack->data);
        stack = stack->next;
    }
    printf("\n");
}

int main() {
    struct Stack* stack;
    initialize(&stack);
    int n, data;

    printf("Enter the number of elements in the stack: ");
    scanf("%d", &n);
    printf("Enter the elements: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &data);
        push(&stack, data);
    }

    printf("Stack elements before sorting: ");
    printStack(stack);

    sortStack(&stack);

    printf("Stack elements after sorting: ");
    printStack(stack);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of elements in the stack: 5
Enter the elements: 30 -5 18 14 -3
Stack elements before sorting: -3 14 18 -5 30 
Stack elements after sorting: -5 -3 14 18 30 
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>

            <div class="nav2">
                <div class="logo2">
                    <p id="queues">Queues</p>
                </div>
                <p id="qcount">Questions=20</p>
            </div>

            <div id="que1">
                <pre>
                <p>Quesion No. - 1 Implement the operations of simple queue in an integer array (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

#define MAX_SIZE 5

struct Queue {
    int* array;
    int front, rear;
    int capacity;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        return NULL;
    }
    queue->capacity = MAX_SIZE;
    queue->array = (int*)malloc(queue->capacity * sizeof(int));
    if (!queue->array) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isFull(struct Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

void insert(struct Queue* queue, int value) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % queue->capacity;
    }
    queue->array[queue->rear] = value;
}

int delete(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int value = queue->array[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % queue->capacity;
    }
    return value;
}

int peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->array[queue->front];
}

int main() {
    struct Queue* queue = createQueue();
    int choice, value;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                insert(queue, value);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(queue->array);
    free(queue);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Element at front: 10
Element at front: 30
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que2">
                <pre> 
                <p>Quesion No. - 2 Implement the operations of simple queue in an string array (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Queue {
    char** array;
    int front, rear;
    int capacity;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        return NULL;
    }
    queue->capacity = MAX_SIZE;
    queue->array = (char**)malloc(queue->capacity * sizeof(char*));
    for (int i = 0; i < queue->capacity; i++) {
        queue->array[i] = (char*)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isFull(struct Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

void insert(struct Queue* queue, char* value) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % queue->capacity;
    }
    strcpy(queue->array[queue->rear], value);
}

char* delete(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char* value = queue->array[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % queue->capacity;
    }
    return value;
}

char* peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->array[queue->front];
}

int main() {
    struct Queue* queue = createQueue();
    char value[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", value);
                insert(queue, value);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    for (int i = 0; i < queue->capacity; i++) {
        free(queue->array[i]);
    }
    free(queue->array);
    free(queue);
    return 0;
}
                </code>
                <p>Output-</p>
                <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: World

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: World

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que3">
                <pre>
                <p>Quesion No. - 3 Implement the operations of queue dynamically of integers (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory error\n");
        return NULL;
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        printf("Memory error\n");
        return NULL;
    }
    queue->front = queue->rear = NULL;
    return queue;
}

void insert(struct Queue* queue, int data) {
    struct Node* newNode = createNode(data);
    if (!newNode) {
        return;
    }
    if (!queue->rear) {
        queue->front = queue->rear = newNode;
        return;
    }
    queue->rear->next = newNode;
    queue->rear = newNode;
}

int delete(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    struct Node* temp = queue->front;
    int data = temp->data;
    queue->front = queue->front->next;
    if (!queue->front) {
        queue->rear = NULL;
    }
    free(temp);
    return data;
}

int peek(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->front->data;
}

int main() {
    struct Queue* queue = createQueue();
    int data, choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    // Free the memory
    struct Node* current = queue->front;
    struct Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    free(queue);
    return 0;
}
                </code>
                <p>Output-</p>
                <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 20

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 10

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 20

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: 30

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que4">
                <pre>
                <p>Quesion No. - 4 Implement the operations of queue dynamically of string (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>

#define MAX_LENGTH 50

struct Node {
    char data[MAX_LENGTH];
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* createNode(char* data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory error\n");
        return NULL;
    }
    strcpy(newNode->data, data);
    newNode->next = NULL;
    return newNode;
}

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        printf("Memory error\n");
        return NULL;
    }
    queue->front = queue->rear = NULL;
    return queue;
}

void insert(struct Queue* queue, char* data) {
    struct Node* newNode = createNode(data);
    if (!newNode) {
        return;
    }
    if (!queue->rear) {
        queue->front = queue->rear = newNode;
        return;
    }
    queue->rear->next = newNode;
    queue->rear = newNode;
}

char* delete(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    struct Node* temp = queue->front;
    char* data = temp->data;
    queue->front = queue->front->next;
    if (!queue->front) {
        queue->rear = NULL;
    }
    free(temp);
    return data;
}

char* peek(struct Queue* queue) {
    if (!queue->front) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->front->data;
}

int isEmpty(struct Queue* queue) {
    return !queue->front;
}

int main() {
    struct Queue* queue = createQueue();
    char data[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    // Free the memory
    struct Node* current = queue->front;
    struct Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    free(queue);
    return 0;
}            
                </code>
                <p>Output-</p>
                <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: World

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Hello

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: World

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que5">
                <pre>
                <p>Quesion No. - 5 Implement the operations of circular queue in an integer array (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

#define MAX_SIZE 5

struct CircularQueue {
    int *arr;
    int front, rear;
};

struct CircularQueue *createQueue() {
    struct CircularQueue *queue = (struct CircularQueue *)malloc(sizeof(struct CircularQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(queue->arr)) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct CircularQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct CircularQueue *queue) {
    return ((queue->rear + 1) % MAX_SIZE == queue->front);
}

void insert(struct CircularQueue *queue, int data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % MAX_SIZE;
    }
    queue->arr[queue->rear] = data;
    printf("%d inserted successfully.\n", data);
}

int delete(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % MAX_SIZE;
    }
    return data;
}

int peek(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->arr[queue->front];
}

int main() {
    struct CircularQueue *queue = createQueue();
    int data, choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %d\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %d\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    free(queue->arr);
    free(queue);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
1 inserted successfully.
2 inserted successfully.
3 inserted successfully.
4 inserted successfully.
Queue is full. Insertion failed.
Deleted element: 1
Element at front: 2
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que6">
                <pre>
                <p>Quesion No. - 6 Implement the operations of circular queue in an string array (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct CircularQueue {
    char **arr;
    int front, rear;
};

struct CircularQueue *createQueue() {
    struct CircularQueue *queue = (struct CircularQueue *)malloc(sizeof(struct CircularQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(queue->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        queue->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct CircularQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct CircularQueue *queue) {
    return ((queue->rear + 1) % MAX_SIZE == queue->front);
}

void insert(struct CircularQueue *queue, char *data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
    } else {
        queue->rear = (queue->rear + 1) % MAX_SIZE;
    }
    strcpy(queue->arr[queue->rear], data);
    printf("%s inserted successfully.\n", data);
}

char *delete (struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char *data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front = (queue->front + 1) % MAX_SIZE;
    }
    return data;
}

char *peek(struct CircularQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->arr[queue->front];
}

int main() {
    struct CircularQueue *queue = createQueue();
    char data[MAX_LENGTH];
    int choice;

    do {
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Peek");
        printf("\n0. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%s", data);
                insert(queue, data);
                break;
            case 2:
                printf("Deleted element: %s\n", delete(queue));
                break;
            case 3:
                printf("Element at front: %s\n", peek(queue));
                break;
            case 0:
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 0);

    for (int i = 0; i < MAX_SIZE; i++) {
        free(queue->arr[i]);
    }
    free(queue->arr);
    free(queue);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Apple
Apple inserted successfully.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 1
Enter value to insert: Banana
Banana inserted successfully.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 3
Element at front: Apple

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Apple

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Deleted element: Banana

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 2
Queue is empty. Deletion failed.

1. Insert
2. Delete
3. Peek
0. Exit
Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que7">
                <pre>
                <p>Quesion No. - 7 Implement the operations of priority queue in an integer array (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

#define MAX_SIZE 5

struct PriorityQueue {
    int *arr;
    int front, rear;
};

struct PriorityQueue *createQueue() {
    struct PriorityQueue *queue = (struct PriorityQueue *)malloc(sizeof(struct PriorityQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(queue->arr)) {
        return NULL;
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct PriorityQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct PriorityQueue *queue) {
    return (queue->rear == MAX_SIZE - 1);
}

void insert(struct PriorityQueue *queue, int data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
        queue->arr[queue->rear] = data;
    } else {
        int i, j;
        for (i = 0; i <= queue->rear; i++) {
            if (data >= queue->arr[i]) {
                for (j = queue->rear + 1; j > i; j--) {
                    queue->arr[j] = queue->arr[j - 1];
                }
                queue->arr[i] = data;
                break;
            }
        }
        if (i == queue->rear + 1) {
            queue->arr[i] = data;
        }
        queue->rear++;
    }
    printf("%d inserted successfully.\n", data);
}

int delete (struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return -1;
    }
    int data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front++;
    }
    return data;
}

int peek(struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return -1;
    }
    return queue->arr[queue->front];
}

int main() {
    struct PriorityQueue *queue = createQueue();

    insert(queue, 3);
    insert(queue, 5);
    insert(queue, 2);
    insert(queue, 1);
    insert(queue, 4);
    insert(queue, 6);

    printf("Deleted element: %d\n", delete(queue));
    printf("Element at front: %d\n", peek(queue));

    free(queue->arr);
    free(queue);
    return 0;
}
 
                </code>
                <p>Output-</p>
                <code>
3 inserted successfully.
5 inserted successfully.
2 inserted successfully.
1 inserted successfully.
4 inserted successfully.
Queue is full. Insertion failed.
Deleted element: 1
Element at front: 2

                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que8">
                <pre>
                <p>Quesion No. - 8 Implement the operations of priority queue in an string array (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct PriorityQueue {
    char **arr;
    int front, rear;
};

struct PriorityQueue *createQueue() {
    struct PriorityQueue *queue = (struct PriorityQueue *)malloc(sizeof(struct PriorityQueue));
    if (!queue) {
        return NULL;
    }
    queue->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(queue->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        queue->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    queue->front = queue->rear = -1;
    return queue;
}

int isEmpty(struct PriorityQueue *queue) {
    return (queue->front == -1);
}

int isFull(struct PriorityQueue *queue) {
    return (queue->rear == MAX_SIZE - 1);
}

void insert(struct PriorityQueue *queue, char *data) {
    if (isFull(queue)) {
        printf("Queue is full. Insertion failed.\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = queue->rear = 0;
        strcpy(queue->arr[queue->rear], data);
    } else {
        int i, j;
        for (i = 0; i <= queue->rear; i++) {
            if (strcmp(data, queue->arr[i]) >= 0) {
                for (j = queue->rear + 1; j > i; j--) {
                    strcpy(queue->arr[j], queue->arr[j - 1]);
                }
                strcpy(queue->arr[i], data);
                break;
            }
        }
        if (i == queue->rear + 1) {
            strcpy(queue->arr[i], data);
        }
        queue->rear++;
    }
    printf("%s inserted successfully.\n", data);
}

char *delete (struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Deletion failed.\n");
        return "";
    }
    char *data = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1;
    } else {
        queue->front++;
    }
    return data;
}

char *peek(struct PriorityQueue *queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Peek failed.\n");
        return "";
    }
    return queue->arr[queue->front];
}

int main() {
    struct PriorityQueue *queue = createQueue();

    insert(queue, "apple");
    insert(queue, "orange");
    insert(queue, "banana");
    insert(queue, "kiwi");
    insert(queue, "grapes");
    insert(queue, "cherry");

    printf("Deleted element: %s\n", delete(queue));
    printf("Element at front: %s\n", peek(queue));

    for (int i = 0; i < MAX_SIZE; i++) {
        free(queue->arr[i]);
    }
    free(queue->arr);
    free(queue);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
apple inserted successfully.
orange inserted successfully.
banana inserted successfully.
kiwi inserted successfully.
grapes inserted successfully.
Queue is full. Insertion failed.
Deleted element: apple
Element at front: banana
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que9">
                <pre>
                <p>Quesion No. - 9 Implement the operations of double ended queue in an integer array (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

#define MAX_SIZE 5

struct Deque {
    int *arr;
    int front, rear;
};

struct Deque *createDeque() {
    struct Deque *deque = (struct Deque *)malloc(sizeof(struct Deque));
    if (!deque) {
        return NULL;
    }
    deque->arr = (int *)malloc(MAX_SIZE * sizeof(int));
    if (!(deque->arr)) {
        return NULL;
    }
    deque->front = -1;
    deque->rear = 0;
    return deque;
}

int isEmpty(struct Deque *deque) {
    return (deque->front == -1);
}

int isFull(struct Deque *deque) {
    return ((deque->front == 0 && deque->rear == MAX_SIZE - 1) || deque->front == deque->rear + 1);
}

void insertFront(struct Deque *deque, int data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the front failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->front == 0) {
        deque->front = MAX_SIZE - 1;
    } else {
        deque->front--;
    }
    deque->arr[deque->front] = data;
    printf("%d inserted at the front successfully.\n", data);
}

void insertRear(struct Deque *deque, int data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the rear failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->rear == MAX_SIZE - 1) {
        deque->rear = 0;
    } else {
        deque->rear++;
    }
    deque->arr[deque->rear] = data;
    printf("%d inserted at the rear successfully.\n", data);
}

int deleteFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the front failed.\n");
        return -1;
    }
    int data = deque->arr[deque->front];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->front == MAX_SIZE - 1) {
        deque->front = 0;
    } else {
        deque->front++;
    }
    return data;
}

int deleteRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the rear failed.\n");
        return -1;
    }
    int data = deque->arr[deque->rear];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->rear == 0) {
        deque->rear = MAX_SIZE - 1;
    } else {
        deque->rear--;
    }
    return data;
}

int getFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the front failed.\n");
        return -1;
    }
    return deque->arr[deque->front];
}

int getRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the rear failed.\n");
        return -1;
    }
    return deque->arr[deque->rear];
}

int main() {
    struct Deque *deque = createDeque();

    insertFront(deque, 3);
    insertRear(deque, 5);
    insertFront(deque, 2);
    insertRear(deque, 4);

    printf("Deleted element from front: %d\n", deleteFront(deque));
    printf("Deleted element from rear: %d\n", deleteRear(deque));
    printf("Element at front: %d\n", getFront(deque));
    printf("Element at rear: %d\n", getRear(deque));

    free(deque->arr);
    free(deque);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
3 inserted at the front successfully.
5 inserted at the rear successfully.
2 inserted at the front successfully.
4 inserted at the rear successfully.
Deleted element from front: 2
Deleted element from rear: 4
Element at front: 3
Element at rear: 5
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que10">
                <pre>
                <p>Quesion No. - 10 Implement the operations of double ended queue in an string array (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>

#define MAX_SIZE 5
#define MAX_LENGTH 50

struct Deque {
    char **arr;
    int front, rear;
};

struct Deque *createDeque() {
    struct Deque *deque = (struct Deque *)malloc(sizeof(struct Deque));
    if (!deque) {
        return NULL;
    }
    deque->arr = (char **)malloc(MAX_SIZE * sizeof(char *));
    if (!(deque->arr)) {
        return NULL;
    }
    for (int i = 0; i < MAX_SIZE; i++) {
        deque->arr[i] = (char *)malloc(MAX_LENGTH * sizeof(char));
    }
    deque->front = -1;
    deque->rear = 0;
    return deque;
}

int isEmpty(struct Deque *deque) {
    return (deque->front == -1);
}

int isFull(struct Deque *deque) {
    return ((deque->front == 0 && deque->rear == MAX_SIZE - 1) || deque->front == deque->rear + 1);
}

void insertFront(struct Deque *deque, char *data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the front failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->front == 0) {
        deque->front = MAX_SIZE - 1;
    } else {
        deque->front--;
    }
    strcpy(deque->arr[deque->front], data);
    printf("%s inserted at the front successfully.\n", data);
}

void insertRear(struct Deque *deque, char *data) {
    if (isFull(deque)) {
        printf("Deque is full. Insertion at the rear failed.\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = deque->rear = 0;
    } else if (deque->rear == MAX_SIZE - 1) {
        deque->rear = 0;
    } else {
        deque->rear++;
    }
    strcpy(deque->arr[deque->rear], data);
    printf("%s inserted at the rear successfully.\n", data);
}

char *deleteFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the front failed.\n");
        return "";
    }
    char *data = deque->arr[deque->front];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->front == MAX_SIZE - 1) {
        deque->front = 0;
    } else {
        deque->front++;
    }
    return data;
}

char *deleteRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Deletion from the rear failed.\n");
        return "";
    }
    char *data = deque->arr[deque->rear];
    if (deque->front == deque->rear) {
        deque->front = deque->rear = -1;
    } else if (deque->rear == 0) {
        deque->rear = MAX_SIZE - 1;
    } else {
        deque->rear--;
    }
    return data;
}

char *getFront(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the front failed.\n");
        return "";
    }
    return deque->arr[deque->front];
}

char *getRear(struct Deque *deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty. Peek from the rear failed.\n");
        return "";
    }
    return deque->arr[deque->rear];
}

int main() {
    struct Deque *deque = createDeque();

    insertFront(deque, "apple");
    insertRear(deque, "banana");
    insertFront(deque, "orange");
    insertRear(deque, "cherry");

    printf("Deleted element from front: %s\n", deleteFront(deque));
    printf("Deleted element from rear: %s\n", deleteRear(deque));
    printf("Element at front: %s\n", getFront(deque));
    printf("Element at rear: %s\n", getRear(deque));

    for (int i = 0; i < MAX_SIZE; i++) {
        free(deque->arr[i]);
    }
    free(deque->arr);
    free(deque);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
apple inserted at the front successfully.
banana inserted at the rear successfully.
orange inserted at the front successfully.
cherry inserted at the rear successfully.
Deleted element from front: orange
Deleted element from rear: cherry
Element at front: apple
Element at rear: banana
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que11">
                <pre>
                <p>Quesion No. - 11 Implement the operations of priority queue dynamically of integers (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

struct Node {
    int data;
    int priority;
    struct Node *next;
};

struct Node *front = NULL;

void insert(int data, int priority) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->priority = priority;
    if (front == NULL || priority < front->priority) {
        newNode->next = front;
        front = newNode;
    } else {
        struct Node *temp = front;
        while (temp->next != NULL && temp->next->priority <= priority) {
            temp = temp->next;
        }
        newNode->next = temp->next;
        temp->next = newNode;
    }
}

void delete() {
    if (front == NULL) {
        printf("Priority queue is empty. Deletion failed.\n");
        return;
    }
    struct Node *temp = front;
    front = front->next;
    free(temp);
}

int peek() {
    if (front == NULL) {
        printf("Priority queue is empty. Peek failed.\n");
        return -1;
    }
    return front->data;
}

int isEmpty() {
    return front == NULL;
}

int isFull() {
    return 0;
}

int main() {
    insert(5, 2);
    insert(10, 1);
    insert(15, 0);

    printf("Element at front: %d\n", peek());
    delete();
    printf("Element at front after deletion: %d\n", peek());

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Element at front: 15
Element at front after deletion: 10
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que12">
                <pre>
                <p>Quesion No. - 12 Implement the operations of priority queue dynamically of string (insert, delete, peek, isempty, isfull)
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltstring.h>

struct Node {
    char *data;
    int priority;
    struct Node *next;
};

struct Node *front = NULL;

void insert(char *data, int priority) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = strdup(data);
    newNode->priority = priority;
    if (front == NULL || priority < front->priority) {
        newNode->next = front;
        front = newNode;
    } else {
        struct Node *temp = front;
        while (temp->next != NULL && temp->next->priority <= priority) {
            temp = temp->next;
        }
        newNode->next = temp->next;
        temp->next = newNode;
    }
}

void delete() {
    if (front == NULL) {
        printf("Priority queue is empty. Deletion failed.\n");
        return;
    }
    struct Node *temp = front;
    front = front->next;
    free(temp->data);
    free(temp);
}

char *peek() {
    if (front == NULL) {
        printf("Priority queue is empty. Peek failed.\n");
        return "";
    }
    return front->data;
}

int isEmpty() {
    return front == NULL;
}

int isFull() {
    return 0;
}

int main() {
    insert("apple", 2);
    insert("banana", 1);
    insert("cherry", 0);

    printf("Element at front: %s\n", peek());
    delete();
    printf("Element at front after deletion: %s\n", peek());

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Element at front: cherry
Element at front after deletion: banana
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que13">
                <pre>
                <p>Quesion No. - 13 Find a tour that visits all stations
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#define MAX 100

int stations = 0;
int graph[MAX][MAX];
int visited[MAX] = {0};
int queue[MAX], front = -1, rear = -1;

void enqueue(int item) {
    if (rear == MAX - 1) {
        printf("Queue Overflow\n");
    } else {
        if (front == -1)
            front = 0;
        rear++;
        queue[rear] = item;
    }
}

int dequeue() {
    int item;
    if (front == -1 || front > rear) {
        printf("Queue Underflow\n");
        exit(1);
    }
    item = queue[front];
    front++;
    return item;
}

void findTour() {
    int i, current;
    enqueue(0);
    visited[0] = 1;

    while (front <= rear) {
        current = dequeue();
        printf("%d ", current);

        for (i = 0; i < stations; i++) {
            if (!visited[i] && graph[current][i] == 1) {
                enqueue(i);
                visited[i] = 1;
            }
        }
    }
}

int main() {
    int i, j;
    printf("Enter the number of stations: ");
    scanf("%d", &stations);

    printf("Enter the adjacency matrix for the stations (0/1):\n");
    for (i = 0; i < stations; i++) {
        for (j = 0; j < stations; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    printf("The tour is: ");
    findTour();
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Enter the number of stations: 4
Enter the adjacency matrix for the stations (0/1):
0 1 1 0
1 0 1 0
1 1 0 1
0 0 1 0
The tour is: 0 1 2 3
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que14">
                <pre>
                <p>Quesion No. - 14 Longest Valid String
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>
#include &ltstdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue* createQueue() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue* queue, int data) {
    Node* temp = (Node*)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue* queue) {
    if (queue->front == NULL)
        return -1;

    Node* temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

int longestValidSubstring(char* s) {
    int n = strlen(s);
    Queue* queue = createQueue();
    int result = 0;

    enqueue(queue, -1);

    for (int i = 0; i < n; i++) {
        if (s[i] == '(')
            enqueue(queue, i);
        else {
            dequeue(queue);
            if (!queue->front)
                enqueue(queue, i);
            else
                result = result > (i - queue->front->data) ? result : (i - queue->front->data);
        }
    }
    return result;
}

int main() {
    char s[] = "((())()";
    printf("The length of the longest valid substring is: %d", longestValidSubstring(s));
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
The length of the longest valid substring is: 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que15">
                <pre>
                <p>Quesion No. - 15 Next larger Element
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

#define SIZE 100

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue *createQueue() {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue *queue, int data) {
    Node *temp = (Node *)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue *queue) {
    if (queue->front == NULL)
        return -1;

    Node *temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

void nextLargerElement(int arr[], int n) {
    Queue *queue = createQueue();

    enqueue(queue, arr[0]);

    for (int i = 1; i < n; i++) {
        int next = arr[i];

        if (queue->front == NULL) {
            enqueue(queue, next);
            continue;
        }

        while (queue->front != NULL) {
            int element = dequeue(queue);

            if (element < next)
                printf("%d -- %d\n", element, next);
            else {
                enqueue(queue, element);
                break;
            }
        }
        enqueue(queue, next);
    }

    while (queue->front != NULL) {
        int element = dequeue(queue);
        printf("%d -- %d\n", element, -1);
    }
}

int main() {
    int arr[] = {11, 13, 21, 3};
    int n = sizeof(arr) / sizeof(arr[0]);

    nextLargerElement(arr, n);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
11 -- 13
13 -- 21
21 -- -1
3 -- -1
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que16">
                <pre>
                <p>Quesion No. - 16 Next smaller element
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

#define SIZE 100

typedef struct Node {
    int data;
    struct Node *next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue *createQueue() {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

void enqueue(Queue *queue, int data) {
    Node *temp = (Node *)malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    queue->rear->next = temp;
    queue->rear = temp;
}

int dequeue(Queue *queue) {
    if (queue->front == NULL)
        return -1;

    Node *temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL)
        queue->rear = NULL;

    int data = temp->data;
    free(temp);
    return data;
}

void nextSmallerElement(int arr[], int n) {
    Queue *queue = createQueue();

    enqueue(queue, arr[0]);

    for (int i = 1; i < n; i++) {
        int next = arr[i];

        if (queue->front == NULL) {
            enqueue(queue, next);
            continue;
        }

        while (queue->front != NULL) {
            int element = dequeue(queue);

            if (element > next)
                printf("%d -- %d\n", element, next);
            else {
                enqueue(queue, element);
                break;
            }
        }
        enqueue(queue, next);
    }

    while (queue->front != NULL) {
        int element = dequeue(queue);
        printf("%d -- %d\n", element, -1);
    }
}

int main() {
    int arr[] = {4, 8, 5, 2, 25};
    int n = sizeof(arr) / sizeof(arr[0]);

    nextSmallerElement(arr, n);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
4 -- 2
8 -- 5
5 -- 2
2 -- -1
25 -- -1
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que17">
                <pre>
                <p>Quesion No. - 17 Queue based approach for first non repeating character in a stream
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>
#define MAX_CHAR 26

typedef struct Queue {
    int front, rear;
    unsigned capacity;
    char* array;
} Queue;

Queue* createQueue(unsigned capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->capacity = capacity;
    queue->front = queue->rear = -1;
    queue->array = (char*)malloc(queue->capacity * sizeof(char));
    return queue;
}

int isFull(Queue* queue) {
    return (queue->rear + 1) % queue->capacity == queue->front;
}

int isEmpty(Queue* queue) {
    return queue->front == -1;
}

void enqueue(Queue* queue, char item) {
    if (isFull(queue))
        return;
    if (isEmpty(queue))
        queue->front = 0;
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->array[queue->rear] = item;
}

char dequeue(Queue* queue) {
    if (isEmpty(queue))
        return '\0';
    char item = queue->array[queue->front];
    if (queue->front == queue->rear)
        queue->front = queue->rear = -1;
    else
        queue->front = (queue->front + 1) % queue->capacity;
    return item;
}

void findFirstNonRepeating(char* stream) {
    Queue* queue = createQueue(MAX_CHAR);
    int charCount[MAX_CHAR] = {0};

    for (int i = 0; stream[i]; i++) {
        enqueue(queue, stream[i]);
        charCount[stream[i] - 'a']++;

        while (!isEmpty(queue)) {
            if (charCount[queue->array[queue->front] - 'a'] > 1)
                dequeue(queue);
            else {
                printf("First non-repeating character so far is %c\n", queue->array[queue->front]);
                break;
            }
        }
        if (isEmpty(queue))
            printf("No non-repeating character so far\n");
    }
}

int main() {
    char stream[] = "abacabad";
    findFirstNonRepeating(stream);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
First non-repeating character so far is a
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is b
First non-repeating character so far is d
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que18">
                <pre>
                <p>Quesion No. - 18 Reverse first k elements of queue
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

typedef struct Queue {
    int front, rear, size;
    unsigned capacity;
    int* array;
} Queue;

Queue* createQueue(unsigned capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->capacity = capacity;
    queue->front = queue->size = 0;
    queue->rear = capacity - 1;
    queue->array = (int*)malloc(queue->capacity * sizeof(int));
    return queue;
}

int isFull(Queue* queue) {
    return (queue->size == queue->capacity);
}

int isEmpty(Queue* queue) {
    return (queue->size == 0);
}

void enqueue(Queue* queue, int item) {
    if (isFull(queue))
        return;
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->array[queue->rear] = item;
    queue->size = queue->size + 1;
}

int dequeue(Queue* queue) {
    if (isEmpty(queue))
        return -1;
    int item = queue->array[queue->front];
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size = queue->size - 1;
    return item;
}

void reverseKelements(Queue* queue, int k) {
    if (isEmpty(queue) || k > queue->size)
        return;

    int* temp = (int*)malloc(k * sizeof(int));

    for (int i = 0; i < k; i++)
        temp[i] = dequeue(queue);

    for (int i = k - 1; i >= 0; i--)
        enqueue(queue, temp[i]);

    for (int i = 0; i < queue->size - k; i++)
        enqueue(queue, dequeue(queue));

    free(temp);
}

void printQueue(Queue* queue) {
    for (int i = 0; i < queue->size; i++)
        printf("%d ", queue->array[(queue->front + i) % queue->capacity]);
    printf("\n");
}

int main() {
    Queue* queue = createQueue(10);
    for (int i = 1; i <= 10; i++)
        enqueue(queue, i);

    int k = 5;
    printf("Original queue: ");
    printQueue(queue);
    reverseKelements(queue, k);
    printf("Queue after reversing the first %d elements: ", k);
    printQueue(queue);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Original queue: 1 2 3 4 5 6 7 8 9 10
Queue after reversing the first 5 elements: 5 4 3 2 1 6 7 8 9 10
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que19">
                <pre>
                <p>Quesion No. - 19 Queue Reversal
                </p>
                <code>
#include &ltstdio.h>
#include &ltstdlib.h>

#define SIZE 5

typedef struct Queue {
    int items[SIZE];
    int front;
    int rear;
} Queue;

void createQueue(Queue* q) {
    q->front = -1;
    q->rear = -1;
}

int isFull(Queue* q) {
    if ((q->front == q->rear + 1) || (q->front == 0 && q->rear == SIZE - 1))
        return 1;
    return 0;
}

int isEmpty(Queue* q) {
    if (q->front == -1)
        return 1;
    return 0;
}

void enQueue(Queue* q, int value) {
    if (isFull(q))
        printf("\nQueue is full!");
    else {
        if (q->front == -1)
            q->front = 0;
        q->rear = (q->rear + 1) % SIZE;
        q->items[q->rear] = value;
    }
}

int deQueue(Queue* q) {
    int item;
    if (isEmpty(q)) {
        printf("Queue is empty");
        item = -1;
    } else {
        item = q->items[q->front];
        if (q->front == q->rear) {
            q->front = -1;
            q->rear = -1;
        } else {
            q->front = (q->front + 1) % SIZE;
        }
    }
    return item;
}

void reverseQueue(Queue* q) {
    int temp;
    if (isEmpty(q)) {
        printf("Queue is empty");
        return;
    } else {
        while (q->front != q->rear) {
            temp = q->items[q->front];
            q->items[q->front] = q->items[q->rear];
            q->items[q->rear] = temp;
            q->front = (q->front + 1) % SIZE;
            q->rear = (q->rear - 1 + SIZE) % SIZE;
        }
    }
}

void printQueue(Queue* q) {
    int i;
    if (isEmpty(q)) {
        printf("Queue is empty");
    } else {
        printf("\nFront -> %d ", q->front);
        printf("\nItems -> ");
        for (i = q->front; i != q->rear; i = (i + 1) % SIZE) {
            printf("%d ", q->items[i]);
        }
        printf("%d ", q->items[i]);
        printf("\nRear -> %d", q->rear);
    }
}

int main() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    createQueue(q);
    enQueue(q, 1);
    enQueue(q, 2);
    enQueue(q, 3);
    enQueue(q, 4);
    enQueue(q, 5);
    printf("Original Queue: ");
    printQueue(q);
    reverseQueue(q);
    printf("\nReversed Queue: ");
    printQueue(q);

    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Original Queue: 
Front -> 0 
Items -> 1 2 3 4 5 
Rear -> 4
Reversed Queue: 
Front -> 0 
Items -> 5 4 3 2 1 
Rear -> 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="que20">
                <pre>
                <p>Quesion No. - 20 Rotten-oranges
                </p>
                <code>
#include &ltstdio.h>

#define R 3
#define C 5

struct Node {
    int x;
    int y;
};

int isInsideGrid(int i, int j) {
    return (i >= 0 && i < R && j >= 0 && j < C);
}

int hasFreshOranges(int grid[R][C]) {
    int i, j;
    for (i = 0; i < R; i++) {
        for (j = 0; j < C; j++) {
            if (grid[i][j] == 1) {
                return 1;
            }
        }
    }
    return 0;
}

int findTime(int grid[R][C]) {
    struct Node queue[R * C];
    int front = 0, rear = 0;
    int row[] = {0, 0, 1, -1};
    int col[] = {1, -1, 0, 0};
    int timer = 0;

    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            if (grid[i][j] == 2) {
                queue[rear].x = i;
                queue[rear].y = j;
                rear++;
            }
        }
    }

    queue[rear].x = -1;
    queue[rear].y = -1;
    rear++;

    while (front < rear) {
        int flag = 0;
        while (queue[front].x != -1 && queue[front].y != -1) {
            for (int i = 0; i < 4; i++) {
                int newRow = queue[front].x + row[i];
                int newCol = queue[front].y + col[i];

                if (isInsideGrid(newRow, newCol) && grid[newRow][newCol] == 1) {
                    grid[newRow][newCol] = 2;
                    queue[rear].x = newRow;
                    queue[rear].y = newCol;
                    rear++;
                    if (flag == 0) {
                        flag = 1;
                        timer++;
                    }
                }
            }
            front++;
        }
        front++;
        if (flag == 1 && front < rear) {
            queue[rear].x = -1;
            queue[rear].y = -1;
            rear++;
        }
    }

    return hasFreshOranges(grid) ? -1 : timer;
}

int main() {
    int grid[R][C] = {{2, 1, 0, 2, 1},
                      {1, 0, 1, 2, 1},
                      {1, 0, 0, 2, 1}};

    int result = findTime(grid);
    if (result == -1) {
        printf("All oranges cannot rot");
    } else {
        printf("Time taken for all oranges to rot: %d", result);
    }
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Time taken for all oranges to rot: 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div class="nav2">
                <div class="logo2">
                    <p id="ll">Linked List</p>
                </div>
                <p id="qcount">Questions=13</p>
            </div>
            <div id="ll1">
                <pre>
                <p>Question No. - 1. IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING INTEGER VALUES
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node* next;
            };
            
            struct LinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->next = NULL;
                return newNode;
            }
            
            struct LinkedList* createLinkedList() {
                struct LinkedList* newList = (struct LinkedList*)malloc(sizeof(struct LinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct LinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                newNode->next = list->head;
                list->head = newNode;
            }
            
            void insertAtEnd(struct LinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    return;
                }
                struct Node* current = list->head;
                while (current->next != NULL) {
                    current = current->next;
                }
                current->next = newNode;
            }
            
            void insertAtPosition(struct LinkedList* list, int data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                struct Node* current = list->head;
                int count = 1;
                while (current != NULL && count < position - 1) {
                    current = current->next;
                    count++;
                }
            
                if (current == NULL) {
                    printf("Position out of range\n");
                } else {
                    newNode->next = current->next;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct LinkedList* list) {
                if (list->head != NULL) {
                    struct Node* temp = list->head;
                    list->head = list->head->next;
                    free(temp);
                }
            }
            
            void deleteAtEnd(struct LinkedList* list) {
                if (list->head == NULL) {
                    return;
                }
                if (list->head->next == NULL) {
                    free(list->head);
                    list->head = NULL;
                    return;
                }
            
                struct Node* current = list->head;
                while (current->next->next != NULL) {
                    current = current->next;
                }
                free(current->next);
                current->next = NULL;
            }
            
            void deleteAtPosition(struct LinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    struct Node* temp = list->head;
                    list->head = list->head->next;
                    free(temp);
                    return;
                }
            
                struct Node* current = list->head;
                int count = 1;
                while (current != NULL && count < position - 1) {
                    current = current->next;
                    count++;
                }
            
                if (current == NULL || current->next == NULL) {
                    printf("Position out of range\n");
                } else {
                    struct Node* temp = current->next;
                    current->next = current->next->next;
                    free(temp);
                }
            }
            
            int isEmpty(struct LinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct LinkedList* list) {
                struct Node* current = list->head;
                while (current != NULL) {
                    printf("%d -> ", current->data);
                    current = current->next;
                }
                printf("NULL\n");
            }
            
            int search(struct LinkedList* list, int target) {
                struct Node* current = list->head;
                int position = 1;
                while (current != NULL) {
                    if (current->data == target) {
                        return position;
                    }
                    current = current->next;
                    position++;
                }
                return -1;
            }
            
            int main() {
                struct LinkedList* myList = createLinkedList();
                int choice, data, position, target;
            
                while (1) {
                    printf("\nSingly Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%d", &data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%d", &data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%d", &data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            printf("Linked List: ");
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%d", &target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %d found at position %d\n", target, position);
                            } else {
                                printf("Element %d not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: 10
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: 20
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: 15
            Enter the position: 2
            
            Singly Linked List: 10 -> 15 -> 20 -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Singly Linked List: 10 -> 15 -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 2
            
            Singly Linked List: 10 -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is not empty.
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            Linked List: 10 -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: 20
            Element 20 not found
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll2">
                <pre>
                <p>Question No. - 2. IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING INTEGER VALUES
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node* next;
            };
            
            struct CircularLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->next = NULL;
                return newNode;
            }
            
            struct CircularLinkedList* createCircularLinkedList() {
                struct CircularLinkedList* newList = (struct CircularLinkedList*)malloc(sizeof(struct CircularLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct CircularLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    newNode->next = newNode;
                    list->head = newNode;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    newNode->next = list->head;
                    last->next = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct CircularLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    newNode->next = newNode;
                    list->head = newNode;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    newNode->next = list->head;
                    last->next = newNode;
                }
            }
            
            void insertAtPosition(struct CircularLinkedList* list, int data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    newNode->next = newNode;
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1 && current->next != list->head) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                } else {
                    struct Node* temp = list->head;
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    if (list->head == list->head->next) {
                        list->head = NULL;
                    } else {
                        list->head = list->head->next;
                        last->next = list->head;
                    }
                    free(temp);
                }
            }
            
            void deleteAtEnd(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                } else {
                    struct Node* current = list->head;
                    struct Node* last = list->head;
                    struct Node* prev = NULL;
            
                    while (current->next != list->head) {
                        prev = last;
                        last = current;
                        current = current->next;
                    }
            
                    if (current == list->head) {
                        list->head = NULL;
                    } else {
                        prev->next = list->head;
                    }
                    free(current);
                }
            }
            
            void deleteAtPosition(struct CircularLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
            
                struct Node* current = list->head;
                int count = 1;
                struct Node* prev = NULL;
                while (count < position && current->next != list->head) {
                    prev = current;
                    current = current->next;
                    count++;
                }
            
                if (current == list->head && count == position) {
                    deleteAtEnd(list);
                    return;
                }
            
                if (count != position) {
                    printf("Position out of range\n");
                } else {
                    prev->next = current->next;
                    free(current);
                }
            }
            
            int isEmpty(struct CircularLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                do {
                    printf("%d -> ", current->data);
                    current = current->next;
                } while (current != list->head);
                printf(" (Head)\n");
            }
            
            int search(struct CircularLinkedList* list, int target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                do {
                    if (current->data == target) {
                        return position;
                    }
                    current = current->next;
                    position++;
                } while (current != list->head);
                return -1;
            }
            
            int main() {
                struct CircularLinkedList* myList = createCircularLinkedList();
                int choice, data, position, target;
            
                while (1) {
                    printf("\nSingle Circular Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%d", &data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%d", &data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%d", &data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%d", &target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %d found at position %d\n", target, position);
                            } else {
                                printf("Element %d not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: 10
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: 20
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: 15
            Enter the position: 2
            
            Single Circular Linked List: 10 -> 15 -> 20 ->  (Head)
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Single Circular Linked List: 15 -> 20 ->  (Head)
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 2
            
            Single Circular Linked List: 15 ->  (Head)
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is not empty.
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            Single Circular Linked List: 15 ->  (Head)
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: 20
            Element 20 not found
            
            Single Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll3">
                <pre>
                <p>Question No. - 3. IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING INTEGER VALUES
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node* prev;
                struct Node* next;
            };
            
            struct DoublyLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->prev = NULL;
                newNode->next = NULL;
                return newNode;
            }
            
            struct DoublyLinkedList* createDoublyLinkedList() {
                struct DoublyLinkedList* newList = (struct DoublyLinkedList*)malloc(sizeof(struct DoublyLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct DoublyLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    newNode->next = list->head;
                    list->head->prev = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct DoublyLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newNode;
                    newNode->prev = current;
                }
            }
            
            void insertAtPosition(struct DoublyLinkedList* list, int data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1 && current->next != NULL) {
                        current = current->next;
                        count++;
                    }
                    if (current->next != NULL) {
                        newNode->next = current->next;
                        current->next->prev = newNode;
                    }
                    current->next = newNode;
                    newNode->prev = current;
                }
            }
            
            void deleteAtBeginning(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* temp = list->head;
                list->head = list->head->next;
                if (list->head != NULL) {
                    list->head->prev = NULL;
                }
                free(temp);
            }
            
            void deleteAtEnd(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* current = list->head;
                while (current->next != NULL) {
                    current = current->next;
                }
                if (current->prev != NULL) {
                    current->prev->next = NULL;
                } else {
                    list->head = NULL;
                }
                free(current);
            }
            
            void deleteAtPosition(struct DoublyLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position && current->next != NULL) {
                    current = current->next;
                    count++;
                }
                if (current->prev != NULL) {
                    current->prev->next = current->next;
                } else {
                    list->head = current->next;
                }
                if (current->next != NULL) {
                    current->next->prev = current->prev;
                }
                free(current);
            }
            
            int isEmpty(struct DoublyLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                while (current != NULL) {
                    printf("%d -> ", current->data);
                    current = current->next;
                }
                printf("NULL\n");
            }
            
            int search(struct DoublyLinkedList* list, int target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                while (current != NULL) {
                    if (current->data == target) {
                        return position;
                    }
                    current = current->next;
                    position++;
                }
                return -1;
            }
            
            int main() {
                struct DoublyLinkedList* myList = createDoublyLinkedList();
                int choice, data, position, target;
            
                while (1) {
                    printf("\nDoubly Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%d", &data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%d", &data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%d", &data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            printf("Doubly Linked List: ");
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%d", &target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %d found at position %d\n", target, position);
                            } else {
                                printf("Element %d not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: 10
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: 20
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: 15
            Enter the position: 2
            
            Doubly Linked List: 10 -> 15 -> 20 -> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Doubly Linked List: 15 -> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Doubly Linked List: NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            Doubly Linked List: NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: 20
            Element 20 not found
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll4">
                <pre>
                <p>Question No. - 4. IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING INTEGER VALUES 
                   
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node* prev;
                struct Node* next;
            };
            
            struct DoublyCircularLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->prev = NULL;
                newNode->next = NULL;
                return newNode;
            }
            
            struct DoublyCircularLinkedList* createDoublyCircularLinkedList() {
                struct DoublyCircularLinkedList* newList = (struct DoublyCircularLinkedList*)malloc(sizeof(struct DoublyCircularLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct DoublyCircularLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    struct Node* last = list->head->prev;
                    newNode->next = list->head;
                    newNode->prev = last;
                    last->next = newNode;
                    list->head->prev = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct DoublyCircularLinkedList* list, int data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    struct Node* last = list->head->prev;
                    newNode->next = list->head;
                    newNode->prev = last;
                    last->next = newNode;
                    list->head->prev = newNode;
                }
            }
            
            void insertAtPosition(struct DoublyCircularLinkedList* list, int data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    newNode->prev = current;
                    current->next->prev = newNode;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
            
                struct Node* toDelete = list->head;
                if (toDelete->next == toDelete) {
                    list->head = NULL;
                } else {
                    list->head = toDelete->next;
                    toDelete->prev->next = list->head;
                    list->head->prev = toDelete->prev;
                }
            
                free(toDelete);
            }
            
            void deleteAtEnd(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
            
                struct Node* toDelete = list->head->prev;
                if (toDelete == list->head) {
                    list->head = NULL;
                } else {
                    list->head->prev = toDelete->prev;
                    toDelete->prev->next = list->head;
                }
            
                free(toDelete);
            }
            
            void deleteAtPosition(struct DoublyCircularLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
            
                struct Node* current = list->head;
                int count = 1;
                while (count < position) {
                    current = current->next;
                    count++;
                }
            
                current->prev->next = current->next;
                current->next->prev = current->prev;
            
                free(current);
            }
            
            int isEmpty(struct DoublyCircularLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
            
                struct Node* current = list->head;
                do {
                    printf("%d -> ", current->data);
                    current = current->next;
                } while (current != list->head);
            
                printf("(Head)\n");
            }
            
            int search(struct DoublyCircularLinkedList* list, int target) {
                if (list->head == NULL) {
                    return -1;
                }
            
                struct Node* current = list->head;
                int position = 1;
            
                do {
                    if (current->data == target) {
                        return position;
                    }
            
                    current = current->next;
                    position++;
                } while (current != list->head);
            
                return -1;
            }
            
            int main() {
                struct DoublyCircularLinkedList* myList = createDoublyCircularLinkedList();
                int choice, data, position, target;
            
                while (1) {
                    printf("\nDoubly Circular Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%d", &data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%d", &data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%d", &data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%d", &target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %d found at position %d\n", target, position);
                            } else {
                                printf("Element %d not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: 10
            
            Doubly Circular Linked List: 10 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: 20
            
            Doubly Circular Linked List: 10 -> 20 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: 15
            Enter the position: 2
            
            Doubly Circular Linked List: 10 -> 15 -> 20 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Doubly Circular Linked List: 15 -> 20 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Doubly Circular Linked List: 15 -> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Doubly Circular Linked List: (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: 20
            Element 20 not found
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll5">
                <pre>
                <p>Question No. - 5. IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING STRING VALUES
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            #include &ltstring.h>
            
            struct Node {
                char data[50];
                struct Node* next;
            };
            
            struct LinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(char* data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                strcpy(newNode->data, data);
                newNode->next = NULL;
                return newNode;
            }
            
            struct LinkedList* createLinkedList() {
                struct LinkedList* newList = (struct LinkedList*)malloc(sizeof(struct LinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct LinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                newNode->next = list->head;
                list->head = newNode;
            }
            
            void insertAtEnd(struct LinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newNode;
                }
            }
            
            void insertAtPosition(struct LinkedList* list, char* data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1 && current->next != NULL) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct LinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* temp = list->head;
                list->head = list->head->next;
                free(temp);
            }
            
            void deleteAtEnd(struct LinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (list->head->next == NULL) {
                    free(list->head);
                    list->head = NULL;
                    return;
                }
                struct Node* current = list->head;
                while (current->next->next != NULL) {
                    current = current->next;
                }
                free(current->next);
                current->next = NULL;
            }
            
            void deleteAtPosition(struct LinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position - 1 && current->next != NULL) {
                    current = current->next;
                    count++;
                }
                if (current->next != NULL) {
                    struct Node* temp = current->next;
                    current->next = current->next->next;
                    free(temp);
                } else {
                    printf("Position not found\n");
                }
            }
            
            int isEmpty(struct LinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct LinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                while (current != NULL) {
                    printf("%s -> ", current->data);
                    current = current->next;
                }
                printf("NULL\n");
            }
            
            int search(struct LinkedList* list, char* target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                while (current != NULL) {
                    if (strcmp(current->data, target) == 0) {
                        return position;
                    }
                    current = current->next;
                    position++;
                }
                return -1;
            }
            
            int main() {
                struct LinkedList* myList = createLinkedList();
                int choice, position;
                char data[50], target[50];
            
                while (1) {
                    printf("\nSingly Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%s", data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%s", data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%s", data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%s", target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %s found at position %d\n", target, position);
                            } else {
                                printf("Element %s not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: Alice
            
            Singly Linked List: Alice -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: Bob
            
            Singly Linked List: Alice -> Bob -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: Carol
            Enter the position: 2
            
            Singly Linked List: Alice -> Carol -> Bob -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Singly Linked List: Carol -> Bob -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Singly Linked List: Carol -> NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Singly Linked List: NULL
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: Carol
            Element Carol not found
            
            Singly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll6">
                <pre>
                <p>Question No. - 6. IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING STRING VALUES
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            #include &ltstring.h>
            
            struct Node {
                char data[50];
                struct Node* next;
            };
            
            struct CircularLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(char* data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                strcpy(newNode->data, data);
                newNode->next = NULL;
                return newNode;
            }
            
            struct CircularLinkedList* createCircularLinkedList() {
                struct CircularLinkedList* newList = (struct CircularLinkedList*)malloc(sizeof(struct CircularLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct CircularLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    newNode->next = list->head;
                    list->head = newNode;
                    last->next = newNode;
                }
            }
            
            void insertAtEnd(struct CircularLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    last->next = newNode;
                    newNode->next = list->head;
                }
            }
            
            void insertAtPosition(struct CircularLinkedList* list, char* data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->head;
                if (toDelete->next == toDelete) {
                    list->head = NULL;
                } else {
                    struct Node* last = list->head;
                    while (last->next != list->head) {
                        last = last->next;
                    }
                    list->head = toDelete->next;
                    last->next = list->head;
                }
                free(toDelete);
            }
            
            void deleteAtEnd(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (list->head->next == list->head) {
                    free(list->head);
                    list->head = NULL;
                    return;
                }
                struct Node* current = list->head;
                struct Node* prev = NULL;
                while (current->next != list->head) {
                    prev = current;
                    current = current->next;
                }
                prev->next = list->head;
                free(current);
            }
            
            void deleteAtPosition(struct CircularLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position - 1) {
                    current = current->next;
                    count++;
                }
                struct Node* toDelete = current->next;
                current->next = toDelete->next;
                free(toDelete);
            }
            
            int isEmpty(struct CircularLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct CircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                do {
                    printf("%s -> ", current->data);
                    current = current->next;
                } while (current != list->head);
                printf("(Head)\n");
            }
            
            int search(struct CircularLinkedList* list, char* target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                do {
                    if (strcmp(current->data, target) == 0) {
                        return position;
                    }
                    current = current->next;
                    position++;
                } while (current != list->head);
                return -1;
            }
            
            int main() {
                struct CircularLinkedList* myList = createCircularLinkedList();
                int choice, position;
                char data[50], target[50];
            
                while (1) {
                    printf("\nCircular Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%s", data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%s", data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%s", data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%s", target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %s found at position %d\n", target, position);
                            } else {
                                printf("Element %s not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: Alice
            
            Circular Linked List: Alice -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: Bob
            
            Circular Linked List: Alice -> Bob -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: Carol
            Enter the position: 2
            
            Circular Linked List: Alice -> Carol -> Bob -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Circular Linked List: Carol -> Bob -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Circular Linked List: Carol -> (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Circular Linked List: (Head)
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: Bob
            Element Bob not found
            
            Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll7">
                <pre>
                <p>Question No. - 7. IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING STRING VALUES
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            #include &ltstring.h>
            
            struct Node {
                char data[50];
                struct Node* prev;
                struct Node* next;
            };
            
            struct DoublyLinkedList {
                struct Node* head;
                struct Node* tail;
            };
            
            struct Node* createNode(char* data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                strcpy(newNode->data, data);
                newNode->prev = NULL;
                newNode->next = NULL;
                return newNode;
            }
            
            struct DoublyLinkedList* createDoublyLinkedList() {
                struct DoublyLinkedList* newList = (struct DoublyLinkedList*)malloc(sizeof(struct DoublyLinkedList));
                newList->head = NULL;
                newList->tail = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct DoublyLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    list->tail = newNode;
                } else {
                    newNode->next = list->head;
                    list->head->prev = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct DoublyLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->tail == NULL) {
                    list->head = newNode;
                    list->tail = newNode;
                } else {
                    newNode->prev = list->tail;
                    list->tail->next = newNode;
                    list->tail = newNode;
                }
            }
            
            void insertAtPosition(struct DoublyLinkedList* list, char* data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    list->tail = newNode;
                } else if (position == 2) {
                    newNode->next = list->head->next;
                    newNode->prev = list->head;
                    list->head->next = newNode;
                    if (newNode->next != NULL) {
                        newNode->next->prev = newNode;
                    }
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1 && current != NULL) {
                        current = current->next;
                        count++;
                    }
                    if (current == NULL) {
                        printf("Position not found\n");
                        free(newNode);
                        return;
                    }
                    newNode->next = current->next;
                    newNode->prev = current;
                    if (newNode->next != NULL) {
                        newNode->next->prev = newNode;
                    }
                    current->next = newNode;
                    if (current == list->tail) {
                        list->tail = newNode;
                    }
                }
            }
            
            void deleteAtBeginning(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->head;
                if (toDelete->next != NULL) {
                    toDelete->next->prev = NULL;
                }
                list->head = toDelete->next;
                free(toDelete);
                if (list->head == NULL) {
                    list->tail = NULL;
                }
            }
            
            void deleteAtEnd(struct DoublyLinkedList* list) {
                if (list->tail == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->tail;
                if (toDelete->prev != NULL) {
                    toDelete->prev->next = NULL;
                }
                list->tail = toDelete->prev;
                free(toDelete);
                if (list->tail == NULL) {
                    list->head = NULL;
                }
            }
            
            void deleteAtPosition(struct DoublyLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position && current != NULL) {
                    current = current->next;
                    count++;
                }
                if (current == NULL) {
                    printf("Position not found\n");
                    return;
                }
                struct Node* toDelete = current;
                if (toDelete->prev != NULL) {
                    toDelete->prev->next = toDelete->next;
                }
                if (toDelete->next != NULL) {
                    toDelete->next->prev = toDelete->prev;
                }
                free(toDelete);
                if (current == list->head) {
                    list->head = current->next;
                }
                if (current == list->tail) {
                    list->tail = current->prev;
                }
            }
            
            int isEmpty(struct DoublyLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct DoublyLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                while (current != NULL) {
                    printf("%s <-> ", current->data);
                    current = current->next;
                }
                printf("NULL\n");
            }
            
            int search(struct DoublyLinkedList* list, char* target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                while (current != NULL) {
                    if (strcmp(current->data, target) == 0) {
                        return position;
                    }
                    current = current->next;
                    position++;
                }
                return -1;
            }
            
            int main() {
                struct DoublyLinkedList* myList = createDoublyLinkedList();
                int choice, position;
                char data[50], target[50];
            
                while (1) {
                    printf("\nDoubly Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%s", data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%s", data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%s", data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%s", target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %s found at position %d\n", target, position);
                            } else {
                                printf("Element %s not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: Alice
            
            Doubly Linked List: Alice <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: Bob
            
            Doubly Linked List: Alice <-> Bob <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: Carol
            Enter the position: 2
            
            Doubly Linked List: Alice <-> Carol <-> Bob <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Doubly Linked List: Carol <-> Bob <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Doubly Linked List: Carol <-> NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Doubly Linked List: NULL
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: Bob
            Element Bob not found
            
            Doubly Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll8">
                <pre>
                <p>Question No. - 8. IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING STRING VALUES
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            #include &ltstring.h>
            
            struct Node {
                char data[50];
                struct Node* prev;
                struct Node* next;
            };
            
            struct DoublyCircularLinkedList {
                struct Node* head;
            };
            
            struct Node* createNode(char* data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                strcpy(newNode->data, data);
                newNode->prev = NULL;
                newNode->next = NULL;
                return newNode;
            }
            
            struct DoublyCircularLinkedList* createDoublyCircularLinkedList() {
                struct DoublyCircularLinkedList* newList = (struct DoublyCircularLinkedList*)malloc(sizeof(struct DoublyCircularLinkedList));
                newList->head = NULL;
                return newList;
            }
            
            void insertAtBeginning(struct DoublyCircularLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    newNode->next = list->head;
                    newNode->prev = list->head->prev;
                    list->head->prev->next = newNode;
                    list->head->prev = newNode;
                    list->head = newNode;
                }
            }
            
            void insertAtEnd(struct DoublyCircularLinkedList* list, char* data) {
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    newNode->next = list->head;
                    newNode->prev = list->head->prev;
                    list->head->prev->next = newNode;
                    list->head->prev = newNode;
                }
            }
            
            void insertAtPosition(struct DoublyCircularLinkedList* list, char* data, int position) {
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    insertAtBeginning(list, data);
                    return;
                }
            
                struct Node* newNode = createNode(data);
                if (list->head == NULL) {
                    list->head = newNode;
                    newNode->next = newNode;
                    newNode->prev = newNode;
                } else {
                    struct Node* current = list->head;
                    int count = 1;
                    while (count < position - 1) {
                        current = current->next;
                        count++;
                    }
                    newNode->next = current->next;
                    newNode->prev = current;
                    current->next->prev = newNode;
                    current->next = newNode;
                }
            }
            
            void deleteAtBeginning(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->head;
                if (toDelete->next == toDelete) {
                    list->head = NULL;
                } else {
                    toDelete->prev->next = toDelete->next;
                    toDelete->next->prev = toDelete->prev;
                    list->head = toDelete->next;
                }
                free(toDelete);
            }
            
            void deleteAtEnd(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                struct Node* toDelete = list->head->prev;
                if (toDelete == list->head) {
                    list->head = NULL;
                } else {
                    toDelete->prev->next = list->head;
                    list->head->prev = toDelete->prev;
                }
                free(toDelete);
            }
            
            void deleteAtPosition(struct DoublyCircularLinkedList* list, int position) {
                if (list->head == NULL) {
                    printf("The list is empty. Nothing to delete.\n");
                    return;
                }
                if (position < 1) {
                    printf("Invalid position\n");
                    return;
                }
                if (position == 1) {
                    deleteAtBeginning(list);
                    return;
                }
                struct Node* current = list->head;
                int count = 1;
                while (count < position - 1) {
                    current = current->next;
                    count++;
                }
                struct Node* toDelete = current->next;
                current->next = toDelete->next;
                toDelete->next->prev = current;
                free(toDelete);
            }
            
            int isEmpty(struct DoublyCircularLinkedList* list) {
                return (list->head == NULL);
            }
            
            void display(struct DoublyCircularLinkedList* list) {
                if (list->head == NULL) {
                    printf("The list is empty.\n");
                    return;
                }
                struct Node* current = list->head;
                do {
                    printf("%s <-> ", current->data);
                    current = current->next;
                } while (current != list->head);
                printf("(Head)\n");
            }
            
            int search(struct DoublyCircularLinkedList* list, char* target) {
                if (list->head == NULL) {
                    return -1;
                }
                struct Node* current = list->head;
                int position = 1;
                do {
                    if (strcmp(current->data, target) == 0) {
                        return position;
                    }
                    current = current->next;
                    position++;
                } while (current != list->head);
                return -1;
            }
            
            int main() {
                struct DoublyCircularLinkedList* myList = createDoublyCircularLinkedList();
                int choice, position;
                char data[50], target[50];
            
                while (1) {
                    printf("\nDoubly Circular Linked List Operations:\n");
                    printf("1. Insert at Beginning\n");
                    printf("2. Insert at End\n");
                    printf("3. Insert at Position\n");
                    printf("4. Delete at Beginning\n");
                    printf("5. Delete at End\n");
                    printf("6. Delete at Position\n");
                    printf("7. Is Empty?\n");
                    printf("8. Display\n");
                    printf("9. Search\n");
                    printf("0. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter data to insert at the beginning: ");
                            scanf("%s", data);
                            insertAtBeginning(myList, data);
                            break;
                        case 2:
                            printf("Enter data to insert at the end: ");
                            scanf("%s", data);
                            insertAtEnd(myList, data);
                            break;
                        case 3:
                            printf("Enter data to insert: ");
                            scanf("%s", data);
                            printf("Enter the position: ");
                            scanf("%d", &position);
                            insertAtPosition(myList, data, position);
                            break;
                        case 4:
                            deleteAtBeginning(myList);
                            break;
                        case 5:
                            deleteAtEnd(myList);
                            break;
                        case 6:
                            printf("Enter the position to delete: ");
                            scanf("%d", &position);
                            deleteAtPosition(myList, position);
                            break;
                        case 7:
                            if (isEmpty(myList)) {
                                printf("The list is empty.\n");
                            } else {
                                printf("The list is not empty.\n");
                            }
                            break;
                        case 8:
                            display(myList);
                            break;
                        case 9:
                            printf("Enter the element to search: ");
                            scanf("%s", target);
                            position = search(myList, target);
                            if (position != -1) {
                                printf("Element %s found at position %d\n", target, position);
                            } else {
                                printf("Element %s not found\n", target);
                            }
                            break;
                        case 0:
                            exit(0);
                        default:
                            printf("Invalid choice. Please try again.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 1
            Enter data to insert at the beginning: Alice
            
            Doubly Circular Linked List: Alice <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 2
            Enter data to insert at the end: Bob
            
            Doubly Circular Linked List: Alice <-> Bob <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 3
            Enter data to insert: Carol
            Enter the position: 2
            
            Doubly Circular Linked List: Alice <-> Carol <-> Bob <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 4
            
            Doubly Circular Linked List: Carol <-> Bob <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 5
            
            Doubly Circular Linked List: Carol <-> (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 6
            Enter the position to delete: 1
            
            Doubly Circular Linked List: (Head)
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 7
            The list is empty.
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 8
            The list is empty.
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 9
            Enter the element to search: Bob
            Element Bob not found
            
            Doubly Circular Linked List Operations:
            1. Insert at Beginning
            2. Insert at End
            3. Insert at Position
            4. Delete at Beginning
            5. Delete at End
            6. Delete at Position
            7. Is Empty?
            8. Display
            9. Search
            0. Exit
            Enter your choice: 0
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll9">
                <pre>
                <p>Question No. - 9. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, ADD THEM AND DISPLAY THE ANSWER.
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct PolynomialTerm {
                int coefficient;
                int exponent;
                struct PolynomialTerm* next;
            };
            
            typedef struct PolynomialTerm PolynomialTerm;
            
            PolynomialTerm* createTerm(int coefficient, int exponent) {
                PolynomialTerm* term = (PolynomialTerm*)malloc(sizeof(PolynomialTerm));
                term->coefficient = coefficient;
                term->exponent = exponent;
                term->next = NULL;
                return term;
            }
            
            void insertTerm(PolynomialTerm** head, int coefficient, int exponent) {
                PolynomialTerm* newTerm = createTerm(coefficient, exponent);
            
                if (*head == NULL) {
                    *head = newTerm;
                } else {
                    PolynomialTerm* current = *head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newTerm;
                }
            }
            
            PolynomialTerm* addPolynomials(PolynomialTerm* poly1, PolynomialTerm* poly2) {
                PolynomialTerm* result = NULL;
            
                while (poly1 != NULL && poly2 != NULL) {
                    if (poly1->exponent == poly2->exponent) {
                        int newCoefficient = poly1->coefficient + poly2->coefficient;
                        if (newCoefficient != 0) {
                            insertTerm(&result, newCoefficient, poly1->exponent);
                        }
                        poly1 = poly1->next;
                        poly2 = poly2->next;
                    } else if (poly1->exponent > poly2->exponent) {
                        insertTerm(&result, poly1->coefficient, poly1->exponent);
                        poly1 = poly1->next;
                    } else {
                        insertTerm(&result, poly2->coefficient, poly2->exponent);
                        poly2 = poly2->next;
                    }
                }
            
                while (poly1 != NULL) {
                    insertTerm(&result, poly1->coefficient, poly1->exponent);
                    poly1 = poly1->next;
                }
            
                while (poly2 != NULL) {
                    insertTerm(&result, poly2->coefficient, poly2->exponent);
                    poly2 = poly2->next;
                }
            
                return result;
            }
            
            void displayPolynomial(PolynomialTerm* poly) {
                if (poly == NULL) {
                    printf("0\n");
                    return;
                }
            
                while (poly != NULL) {
                    printf("%d", poly->coefficient);
                    if (poly->exponent > 0) {
                        printf("x^%d", poly->exponent);
                    }
                    if (poly->next != NULL) {
                        if (poly->next->coefficient >= 0) {
                            printf(" + ");
                        } else {
                            printf(" - ");
                        }
                    }
                    poly = poly->next;
                }
                printf("\n");
            }
            
            int main() {
                PolynomialTerm* poly1 = NULL;
                PolynomialTerm* poly2 = NULL;
            
                printf("Enter the first polynomial equation:\n");
                int coefficient, exponent;
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly1, coefficient, exponent);
                } while (1);
            
                printf("Enter the second polynomial equation:\n");
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly2, coefficient, exponent);
                } while (1);
            
                printf("\nFirst Polynomial: ");
                displayPolynomial(poly1);
            
                printf("Second Polynomial: ");
                displayPolynomial(poly2);
            
                PolynomialTerm* result = addPolynomials(poly1, poly2);
                printf("\nResultant Polynomial: ");
                displayPolynomial(result);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Enter the first polynomial equation:
            Enter coefficient (or 0 to finish): 5
            Enter exponent: 2
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 2
            Enter exponent: 0
            Enter coefficient (or 0 to finish): 0
            
            Enter the second polynomial equation:
            Enter coefficient (or 0 to finish): 4
            Enter exponent: 3
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 2
            Enter coefficient (or 0 to finish): 1
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 0
            
            First Polynomial: 5x^2 - 3x^1 + 2
            
            Second Polynomial: 4x^3 - 3x^2 + 1x^1
            
            Resultant Polynomial: 4x^3 + 5x^2 - 6x^1 + 2
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll10">
                <pre>
                <p>Question No. - 10. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, SUBTRACT THEM AND DISPLAY THE ANSWER.
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct PolynomialTerm {
                int coefficient;
                int exponent;
                struct PolynomialTerm* next;
            };
            
            typedef struct PolynomialTerm PolynomialTerm;
            
            PolynomialTerm* createTerm(int coefficient, int exponent) {
                PolynomialTerm* term = (PolynomialTerm*)malloc(sizeof(PolynomialTerm));
                term->coefficient = coefficient;
                term->exponent = exponent;
                term->next = NULL;
                return term;
            }
            
            void insertTerm(PolynomialTerm** head, int coefficient, int exponent) {
                PolynomialTerm* newTerm = createTerm(coefficient, exponent);
            
                if (*head == NULL) {
                    *head = newTerm;
                } else {
                    PolynomialTerm* current = *head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newTerm;
                }
            }
            
            PolynomialTerm* subtractPolynomials(PolynomialTerm* poly1, PolynomialTerm* poly2) {
                PolynomialTerm* result = NULL;
            
                while (poly1 != NULL && poly2 != NULL) {
                    if (poly1->exponent == poly2->exponent) {
                        int newCoefficient = poly1->coefficient - poly2->coefficient;
                        if (newCoefficient != 0) {
                            insertTerm(&result, newCoefficient, poly1->exponent);
                        }
                        poly1 = poly1->next;
                        poly2 = poly2->next;
                    } else if (poly1->exponent > poly2->exponent) {
                        insertTerm(&result, poly1->coefficient, poly1->exponent);
                        poly1 = poly1->next;
                    } else {
                        insertTerm(&result, -poly2->coefficient, poly2->exponent);
                        poly2 = poly2->next;
                    }
                }
            
                while (poly1 != NULL) {
                    insertTerm(&result, poly1->coefficient, poly1->exponent);
                    poly1 = poly1->next;
                }
            
                while (poly2 != NULL) {
                    insertTerm(&result, -poly2->coefficient, poly2->exponent);
                    poly2 = poly2->next;
                }
            
                return result;
            }
            
            void displayPolynomial(PolynomialTerm* poly) {
                if (poly == NULL) {
                    printf("0\n");
                    return;
                }
            
                while (poly != NULL) {
                    printf("%d", poly->coefficient);
                    if (poly->exponent > 0) {
                        printf("x^%d", poly->exponent);
                    }
                    if (poly->next != NULL) {
                        if (poly->next->coefficient >= 0) {
                            printf(" + ");
                        } else {
                            printf(" - ");
                        }
                    }
                    poly = poly->next;
                }
                printf("\n");
            }
            
            int main() {
                PolynomialTerm* poly1 = NULL;
                PolynomialTerm* poly2 = NULL;
            
                printf("Enter the first polynomial equation:\n");
                int coefficient, exponent;
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly1, coefficient, exponent);
                } while (1);
            
                printf("Enter the second polynomial equation:\n");
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly2, coefficient, exponent);
                } while (1);
            
                printf("\nFirst Polynomial: ");
                displayPolynomial(poly1);
            
                printf("Second Polynomial: ");
                displayPolynomial(poly2);
            
                PolynomialTerm* result = subtractPolynomials(poly1, poly2);
                printf("\nResultant Polynomial: ");
                displayPolynomial(result);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Enter the first polynomial equation:
            Enter coefficient (or 0 to finish): 5
            Enter exponent: 3
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 2
            Enter coefficient (or 0 to finish): 2
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 0
            
            Enter the second polynomial equation:
            Enter coefficient (or 0 to finish): 4
            Enter exponent: 3
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 2
            Enter coefficient (or 0 to finish): 1
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 0
            
            First Polynomial: 5x^3 - 3x^2 + 2x^1
            Second Polynomial: 4x^3 - 3x^2 + 1x^1
            
            Resultant Polynomial: 1x^3 + 0x^2 + 1x^1
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="ll11">
                <pre>
                <p>Question No. - 11. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, MULTIPLY THEM AND DISPLAY THE ANSWER.
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct PolynomialTerm {
                int coefficient;
                int exponent;
                struct PolynomialTerm* next;
            };
            
            typedef struct PolynomialTerm PolynomialTerm;
            
            PolynomialTerm* createTerm(int coefficient, int exponent) {
                PolynomialTerm* term = (PolynomialTerm*)malloc(sizeof(PolynomialTerm));
                term->coefficient = coefficient;
                term->exponent = exponent;
                term->next = NULL;
                return term;
            }
            
            void insertTerm(PolynomialTerm** head, int coefficient, int exponent) {
                PolynomialTerm* newTerm = createTerm(coefficient, exponent);
            
                if (*head == NULL) {
                    *head = newTerm;
                } else {
                    PolynomialTerm* current = *head;
                    while (current->next != NULL) {
                        current = current->next;
                    }
                    current->next = newTerm;
                }
            }
            
            PolynomialTerm* multiplyPolynomials(PolynomialTerm* poly1, PolynomialTerm* poly2) {
                PolynomialTerm* result = NULL;
            
                while (poly1 != NULL) {
                    PolynomialTerm* current = poly2;
                    while (current != NULL) {
                        int newCoefficient = poly1->coefficient * current->coefficient;
                        int newExponent = poly1->exponent + current->exponent;
                        insertTerm(&result, newCoefficient, newExponent);
                        current = current->next;
                    }
                    poly1 = poly1->next;
                }
            
                return result;
            }
            
            void displayPolynomial(PolynomialTerm* poly) {
                if (poly == NULL) {
                    printf("0\n");
                    return;
                }
            
                while (poly != NULL) {
                    printf("%d", poly->coefficient);
                    if (poly->exponent > 0) {
                        printf("x^%d", poly->exponent);
                    }
                    if (poly->next != NULL) {
                        if (poly->next->coefficient >= 0) {
                            printf(" + ");
                        } else {
                            printf(" - ");
                        }
                    }
                    poly = poly->next;
                }
                printf("\n");
            }
            
            int main() {
                PolynomialTerm* poly1 = NULL;
                PolynomialTerm* poly2 = NULL;
            
                printf("Enter the first polynomial equation:\n");
                int coefficient, exponent;
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly1, coefficient, exponent);
                } while (1);
            
                printf("Enter the second polynomial equation:\n");
                do {
                    printf("Enter coefficient (or 0 to finish): ");
                    scanf("%d", &coefficient);
                    if (coefficient == 0) {
                        break;
                    }
                    printf("Enter exponent: ");
                    scanf("%d", &exponent);
                    insertTerm(&poly2, coefficient, exponent);
                } while (1);
            
                printf("\nFirst Polynomial: ");
                displayPolynomial(poly1);
            
                printf("Second Polynomial: ");
                displayPolynomial(poly2);
            
                PolynomialTerm* result = multiplyPolynomials(poly1, poly2);
                printf("\nResultant Polynomial: ");
                displayPolynomial(result);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Enter the first polynomial equation:
            Enter coefficient (or 0 to finish): 2
            Enter exponent: 2
            Enter coefficient (or 0 to finish): -3
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 1
            Enter exponent: 0
            Enter coefficient (or 0 to finish): 0
            
            Enter the second polynomial equation:
            Enter coefficient (or 0 to finish): 4
            Enter exponent: 3
            Enter coefficient (or 0 to finish): -2
            Enter exponent: 1
            Enter coefficient (or 0 to finish): 1
            Enter exponent: 0
            Enter coefficient (or 0 to finish): 0
            
            First Polynomial: 2x^2 - 3x^1 + 1
            Second Polynomial: 4x^3 - 2x^1 + 1
            
            Resultant Polynomial: 8x^5 - 4x^3 - 12x^4 + 6x^2 + 4x^3 - 2x^1 + 2x^2 - 1
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            
                                                
            <div class="nav2">
                <div class="logo2">
                    <p id="ss">Searching And Sorting</p>
                </div>
                <p id="qcount">Questions=15</p>
            </div>
            <div id="ss1">
                <pre>
                <p>Quesion No. - 1 Linear Search through iteration
                </p>
                <code>
#include &ltstdio.h>

int linearSearch(int arr[], int n, int x) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == x) {
            return i; // Return the index where the element is found
        }
    }
    return -1; // Return -1 if the element is not found
}

int main() {
    int arr[] = {12, 34, 10, 6, 40};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = linearSearch(arr, n, x);
    if (result == -1) {
        printf("Element is not present in the array");
    } else {
        printf("Element is present at index %d", result);
    }
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Element is present at index 2
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss2">
                <pre>
                <p>Quesion No. - 2 Linear Search through recursion
                </p>
                <code>
#include &ltstdio.h>

int linearSearch(int arr[], int left, int right, int x) {
    if (right < left) {
        return -1; // Element not found
    }

    if (arr[left] == x) {
        return left; // Element found at left index
    }

    return linearSearch(arr, left + 1, right, x); // Recursive call with updated left index
}

int main() {
    int arr[] = {12, 34, 10, 6, 40};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = linearSearch(arr, 0, n - 1, x);
    if (result == -1) {
        printf("Element is not present in the array");
    } else {
        printf("Element is present at index %d", result);
    }
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Element is present at index 2
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss3">
                <pre>
                <p>Quesion No. - 3 Binary Search through iteration
                </p>
                <code>
#include &ltstdio.h>

int binarySearch(int arr[], int left, int right, int x) {
    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == x) {
            return mid; // Element found at mid index
        }

        if (arr[mid] < x) {
            left = mid + 1; // Update left index
        } else {
            right = mid - 1; // Update right index
        }
    }

    return -1; // Element not found
}

int main() {
    int arr[] = {2, 3, 4, 10, 40};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = binarySearch(arr, 0, n - 1, x);
    if (result == -1) {
        printf("Element is not present in the array");
    } else {
        printf("Element is present at index %d", result);
    }
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Element is present at index 3
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss4">
                <pre>
                <p>Quesion No. - 4 Binary Search through recursion
                </p>
                <code>
#include &ltstdio.h>

int binarySearch(int arr[], int left, int right, int x) {
    if (right >= left) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == x) {
            return mid; // Element found at mid index
        }

        if (arr[mid] > x) {
            return binarySearch(arr, left, mid - 1, x); // Search in the left half
        }

        return binarySearch(arr, mid + 1, right, x); // Search in the right half
    }

    return -1; // Element not found
}

int main() {
    int arr[] = {2, 3, 4, 10, 40};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = binarySearch(arr, 0, n - 1, x);
    if (result == -1) {
        printf("Element is not present in the array");
    } else {
        printf("Element is present at index %d", result);
    }
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Element is present at index 3
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss5">
                <pre>
                <p>Quesion No. - 5 Selection Sorting through iteration
                </p>
                <code>
#include &ltstdio.h>

void swap(int *xp, int *yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void selectionSort(int arr[], int n) {
    int i, j, min_idx;
    for (i = 0; i < n - 1; i++) {
        min_idx = i;
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(&arr[min_idx], &arr[i]);
    }
}

void printArray(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);
    selectionSort(arr, n);
    printf("Sorted array: \n");
    printArray(arr, n);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Sorted array: 
11 12 22 25 64
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss6">
                <pre>
                <p>Quesion No. - 6 Bubble Sorting through iteration
                </p>
                <code>
#include &ltstdio.h>

void swap(int *xp, int *yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
            }
        }
    }
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    bubbleSort(arr, n);
    printf("Sorted array: \n");
    printArray(arr, n);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Sorted array: 
11 12 22 25 34 64 90
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss7">
                <pre>
                <p>Quesion No. - 7 Insertion Sorting through Iteration
                </p>
                <code>
#include &ltstdio.h>

void insertionSort(int arr[], int n) {
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

void printArray(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    insertionSort(arr, n);
    printf("Sorted array: \n");
    printArray(arr, n);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Sorted array: 
5 6 11 12 13
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss8">
                <pre>
                <p>Quesion No. - 8 Merge Sort through Iteration
                </p>
                <code>
#include &ltstdio.h>

void merge(int arr[], int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

void printArray(int A[], int size) {
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", A[i]);
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int arr_size = sizeof(arr) / sizeof(arr[0]);

    printf("Given array is \n");
    printArray(arr, arr_size);

    mergeSort(arr, 0, arr_size - 1);

    printf("\nSorted array is \n");
    printArray(arr, arr_size);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Given array is 
12 11 13 5 6 7 
Sorted array is 
5 6 7 11 12 13
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss9">
                <pre>
                <p>Quesion No. - 9 Merge Sort through recursion
                </p>
                <code>
#include &ltstdio.h>

void merge(int arr[], int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

void printArray(int A[], int size) {
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", A[i]);
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int arr_size = sizeof(arr) / sizeof(arr[0]);

    printf("Given array is \n");
    printArray(arr, arr_size);

    mergeSort(arr, 0, arr_size - 1);

    printf("\nSorted array is \n");
    printArray(arr, arr_size);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Given array is 
12 11 13 5 6 7 
Sorted array is 
5 6 7 11 12 13
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss10">
                <pre>
                <p>Quesion No. - 10 Quick Sort through Iteration
                </p>
                <code>
#include &ltstdio.h>

void swap(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    int stack[high - low + 1];
    int top = -1;
    stack[++top] = low;
    stack[++top] = high;
    while (top >= 0) {
        high = stack[top--];
        low = stack[top--];
        int pi = partition(arr, low, high);
        if (pi - 1 > low) {
            stack[++top] = low;
            stack[++top] = pi - 1;
        }
        if (pi + 1 < high) {
            stack[++top] = pi + 1;
            stack[++top] = high;
        }
    }
}

void printArray(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Given array is \n");
    printArray(arr, n);
    quickSort(arr, 0, n - 1);
    printf("Sorted array is \n");
    printArray(arr, n);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Given array is 
10 7 8 9 1 5 
Sorted array is 
1 5 7 8 9 10
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss11">
                <pre>
                <p>Quesion No. - 11 Quick Sort through recursion
                </p>
                <code>
#include &ltstdio.h>

void swap(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void printArray(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Given array is \n");
    printArray(arr, n);
    quickSort(arr, 0, n - 1);
    printf("Sorted array is \n");
    printArray(arr, n);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Given array is 
10 7 8 9 1 5 
Sorted array is 
1 5 7 8 9 10
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss12">
                <pre>
                <p>Quesion No. - 12 Show all the complexities of the searching algorithms with exact time taken
                </p>
                <code>
            
                </code>
                <p>Output-</p>
                <code>
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss13">
                <pre>
                <p>Quesion No. - 13 Show all the complexities of the sorting algorithms with exact time taken
                </p>
                <code>
            
                </code>
                <p>Output-</p>
                <code>
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss14">
                <pre>
                <p>Quesion No. - 14 Sort the string using quick sort
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>

void swap(char* a, char* b) {
    char t = *a;
    *a = *b;
    *b = t;
}

int partition(char arr[], int low, int high) {
    char pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(char arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    char str[] = "quick sort";
    int n = strlen(str);
    printf("Given string is %s\n", str);
    quickSort(str, 0, n - 1);
    printf("Sorted string is %s\n", str);
    return 0;
}
           
                </code>
                <p>Output-</p>
                <code>
Given string is quick sort
Sorted string is cikorstuq
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            
             
            <div id="ss15">
                <pre>
                <p>Quesion No. - 15 Sort the string using merge sort
                </p>
                <code>
#include &ltstdio.h>
#include &ltstring.h>
#include &ltstdlib.h>

void merge(char *arr, int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    char L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(char *arr, int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

int main() {
    char str[] = "mergesort";
    int n = strlen(str);
    printf("Given string is %s\n", str);
    mergeSort(str, 0, n - 1);
    printf("Sorted string is %s\n", str);
    return 0;
}
            
                </code>
                <p>Output-</p>
                <code>
Given string is mergesort
Sorted string is eegmorrst
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div>
            <div class="nav2">
                <div class="logo2">
                    <p id="tree">Trees</p>
                </div>
                <p id="qcount">Questions=20</p>
            </div>
            <div id="tree1">
                <pre>
                <p>Question No. - 1. CONSTRUCT BINARY TREE FROM PREORDER AND INORDER TRAVERSAL
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to find the index of an element in an array
            int findIndex(int* arr, int start, int end, int value) {
                int i;
                for (i = start; i <= end; i++) {
                    if (arr[i] == value) {
                        return i;
                    }
                }
                return -1;
            }
            
            // Function to construct a binary tree from preorder and inorder traversals
            TreeNode* buildTree(int* preorder, int* inorder, int inStart, int inEnd, int* preIndex) {
                if (inStart > inEnd) {
                    return NULL;
                }
            
                TreeNode* node = createNode(preorder[*preIndex]);
                (*preIndex)++;
            
                if (inStart == inEnd) {
                    return node;
                }
            
                int inIndex = findIndex(inorder, inStart, inEnd, node->data);
            
                node->left = buildTree(preorder, inorder, inStart, inIndex - 1, preIndex);
                node->right = buildTree(preorder, inorder, inIndex + 1, inEnd, preIndex);
            
                return node;
            }
            
            // Function to perform an inorder traversal of the constructed tree
            void inorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                inorderTraversal(root->left);
                printf("%d ", root->data);
                inorderTraversal(root->right);
            }
            
            // Function to free the memory of the tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                int preorder[] = {3, 9, 20, 15, 7};
                int inorder[] = {9, 3, 15, 20, 7};
                int preIndex = 0;
            
                int n = sizeof(preorder) / sizeof(preorder[0]);
            
                TreeNode* root = buildTree(preorder, inorder, 0, n - 1, &preIndex);
            
                printf("Inorder traversal of the constructed tree: ");
                inorderTraversal(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Inorder traversal of the constructed tree: 9 3 15 20 7
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree2">
                <pre>
                <p>Question No. - 2. BINARY TREE LEVEL ORDER TRAVERSAL
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Define a structure for a queue to help with level-order traversal
            struct QueueNode {
                TreeNode* data;
                struct QueueNode* next;
            };
            
            typedef struct QueueNode QueueNode;
            
            // Function to create a new node for the binary tree
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to create a new node for the queue
            QueueNode* createQueueNode(TreeNode* data) {
                QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
                newNode->data = data;
                newNode->next = NULL;
                return newNode;
            }
            
            // Function to perform level-order traversal of the binary tree
            void levelOrderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
            
                // Create a queue for level-order traversal
                QueueNode* queue = NULL;
            
                // Enqueue the root node
                QueueNode* queueNode = createQueueNode(root);
                if (queueNode != NULL) {
                    queueNode->next = queue;
                    queue = queueNode;
                }
            
                while (queue != NULL) {
                    // Dequeue a node from the queue
                    TreeNode* currentNode = queue->data;
                    QueueNode* temp = queue;
                    queue = queue->next;
                    free(temp);
            
                    // Process the current node
                    printf("%d ", currentNode->data);
            
                    // Enqueue the left child
                    if (currentNode->left != NULL) {
                        queueNode = createQueueNode(currentNode->left);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
            
                    // Enqueue the right child
                    if (currentNode->right != NULL) {
                        queueNode = createQueueNode(currentNode->right);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
                }
            }
            
            // Function to free the memory of the binary tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                // Construct a sample binary tree
                TreeNode* root = createNode(1);
                root->left = createNode(2);
                root->right = createNode(3);
                root->left->left = createNode(4);
                root->left->right = createNode(5);
                root->right->left = createNode(6);
                root->right->right = createNode(7);
            
                // Perform level-order traversal
                printf("Level-Order Traversal: ");
                levelOrderTraversal(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Level-Order Traversal: 1 2 3 4 5 6 7
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree3">
                <pre>
                <p>Question No. - 3. PRINT LEFT VIEW OF BINARY TREE
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Define a structure for a queue to help with level-order traversal
            struct QueueNode {
                TreeNode* data;
                int level;
                struct QueueNode* next;
            };
            
            typedef struct QueueNode QueueNode;
            
            // Function to create a new node for the binary tree
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to create a new node for the queue
            QueueNode* createQueueNode(TreeNode* data, int level) {
                QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
                newNode->data = data;
                newNode->level = level;
                newNode->next = NULL;
                return newNode;
            }
            
            // Function to print the left view of the binary tree
            void printLeftView(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
            
                // Create a queue for level-order traversal
                QueueNode* queue = NULL;
            
                // Enqueue the root node with level 0
                QueueNode* queueNode = createQueueNode(root, 0);
                if (queueNode != NULL) {
                    queueNode->next = queue;
                    queue = queueNode;
                }
            
                int currentLevel = -1;
            
                while (queue != NULL) {
                    // Dequeue a node from the queue
                    TreeNode* currentNode = queue->data;
                    int level = queue->level;
                    QueueNode* temp = queue;
                    queue = queue->next;
                    free(temp);
            
                    // Check if the level has changed
                    if (level > currentLevel) {
                        // Print the leftmost node of the current level
                        printf("%d ", currentNode->data);
                        currentLevel = level;
                    }
            
                    // Enqueue the left child with the increased level
                    if (currentNode->left != NULL) {
                        queueNode = createQueueNode(currentNode->left, level + 1);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
            
                    // Enqueue the right child with the increased level
                    if (currentNode->right != NULL) {
                        queueNode = createQueueNode(currentNode->right, level + 1);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
                }
            }
            
            // Function to free the memory of the binary tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                // Construct a sample binary tree
                TreeNode* root = createNode(1);
                root->left = createNode(2);
                root->right = createNode(3);
                root->left->left = createNode(4);
                root->left->right = createNode(5);
                root->right->left = createNode(6);
                root->right->right = createNode(7);
            
                // Print the left view of the binary tree
                printf("Left View of Binary Tree: ");
                printLeftView(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Left View of Binary Tree: 1 2 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree4">
                <pre>
                <p>Question No. - 4. DISPLAY THE RIGHT VIEW OF BINARY TREE
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Define a structure for a queue to help with level-order traversal
            struct QueueNode {
                TreeNode* data;
                int level;
                struct QueueNode* next;
            };
            
            typedef struct QueueNode QueueNode;
            
            // Function to create a new node for the binary tree
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to create a new node for the queue
            QueueNode* createQueueNode(TreeNode* data, int level) {
                QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
                newNode->data = data;
                newNode->level = level;
                newNode->next = NULL;
                return newNode;
            }
            
            // Function to print the right view of the binary tree
            void printRightView(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
            
                // Create a queue for level-order traversal
                QueueNode* queue = NULL;
            
                // Enqueue the root node with level 0
                QueueNode* queueNode = createQueueNode(root, 0);
                if (queueNode != NULL) {
                    queueNode->next = queue;
                    queue = queueNode;
                }
            
                int currentLevel = -1;
            
                while (queue != NULL) {
                    // Dequeue a node from the queue
                    TreeNode* currentNode = queue->data;
                    int level = queue->level;
                    QueueNode* temp = queue;
                    queue = queue->next;
                    free(temp);
            
                    // Check if the level has changed
                    if (level > currentLevel) {
                        // Print the rightmost node of the current level
                        printf("%d ", currentNode->data);
                        currentLevel = level;
                    }
            
                    // Enqueue the right child with the increased level
                    if (currentNode->right != NULL) {
                        queueNode = createQueueNode(currentNode->right, level + 1);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
            
                    // Enqueue the left child with the increased level
                    if (currentNode->left != NULL) {
                        queueNode = createQueueNode(currentNode->left, level + 1);
                        if (queueNode != NULL) {
                            queueNode->next = queue;
                            queue = queueNode;
                        }
                    }
                }
            }
            
            // Function to free the memory of the binary tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                // Construct a sample binary tree
                TreeNode* root = createNode(1);
                root->left = createNode(2);
                root->right = createNode(3);
                root->left->left = createNode(4);
                root->left->right = createNode(5);
                root->right->left = createNode(6);
                root->right->right = createNode(7);
            
                // Print the right view of the binary tree
                printf("Right View of Binary Tree: ");
                printRightView(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Right View of Binary Tree: 1 3 7
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree5">
                <pre>
                <p>Question No. - 5. CONSTRUCT BINARY TREE FROM POSTORDER AND INORDER TRAVERSAL
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to find the index of an element in an array
            int findIndex(int* arr, int start, int end, int value) {
                int i;
                for (i = start; i <= end; i++) {
                    if (arr[i] == value) {
                        return i;
                    }
                }
                return -1;
            }
            
            // Function to construct a binary tree from postorder and inorder traversals
            TreeNode* buildTree(int* postorder, int* inorder, int inStart, int inEnd, int* postIndex) {
                if (inStart > inEnd) {
                    return NULL;
                }
            
                TreeNode* node = createNode(postorder[*postIndex]);
                (*postIndex)--;
            
                if (inStart == inEnd) {
                    return node;
                }
            
                int inIndex = findIndex(inorder, inStart, inEnd, node->data);
            
                node->right = buildTree(postorder, inorder, inIndex + 1, inEnd, postIndex);
                node->left = buildTree(postorder, inorder, inStart, inIndex - 1, postIndex);
            
                return node;
            }
            
            // Function to perform an inorder traversal of the constructed tree
            void inorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                inorderTraversal(root->left);
                printf("%d ", root->data);
                inorderTraversal(root->right);
            }
            
            // Function to free the memory of the tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                int postorder[] = {9, 15, 7, 20, 3};
                int inorder[] = {9, 3, 15, 20, 7};
                int postIndex = 4;
            
                int n = sizeof(postorder) / sizeof(postorder[0]);
            
                TreeNode* root = buildTree(postorder, inorder, 0, n - 1, &postIndex);
            
                printf("Inorder traversal of the constructed tree: ");
                inorderTraversal(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Inorder traversal of the constructed tree: 9 3 15 20 7
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree6">
                <pre>
                <p>Question No. - 6. FIND THE MAXIMUM DEPTH OF BINARY TREE
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a binary tree node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to find the maximum depth of a binary tree using DFS
            int maxDepth(TreeNode* root) {
                if (root == NULL) {
                    return 0;
                }
            
                int leftDepth = maxDepth(root->left);
                int rightDepth = maxDepth(root->right);
            
                return (leftDepth > rightDepth) ? leftDepth + 1 : rightDepth + 1;
            }
            
            // Function to free the memory of the tree nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                // Construct a sample binary tree
                TreeNode* root = createNode(1);
                root->left = createNode(2);
                root->right = createNode(3);
                root->left->left = createNode(4);
                root->left->right = createNode(5);
                root->right->left = createNode(6);
                root->right->right = createNode(7);
            
                // Find and print the maximum depth of the binary tree
                int depth = maxDepth(root);
                printf("Maximum Depth of Binary Tree: %d\n", depth);
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Maximum Depth of Binary Tree: 3
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree7">
                <pre>
                <p>Question No. - 7. CREATE BINARY SEARCH TREE USING ARRAYS (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a BST node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new BST node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert a new node in the BST
            TreeNode* insert(TreeNode* root, int data) {
                if (root == NULL) {
                    return createNode(data);
                }
            
                if (data < root->data) {
                    root->left = insert(root->left, data);
                } else if (data > root->data) {
                    root->right = insert(root->right, data);
                }
            
                return root;
            }
            
            // Function to find the minimum element in the BST
            int findMinimum(TreeNode* root) {
                if (root == NULL) {
                    printf("The tree is empty. Minimum element not found.\n");
                    return -1;
                }
                
                while (root->left != NULL) {
                    root = root->left;
                }
            
                return root->data;
            }
            
            // Function to perform an inorder traversal of the BST
            void inorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                inorderTraversal(root->left);
                printf("%d ", root->data);
                inorderTraversal(root->right);
            }
            
            // Function to perform a preorder traversal of the BST
            void preorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                printf("%d ", root->data);
                preorderTraversal(root->left);
                preorderTraversal(root->right);
            }
            
            // Function to perform a postorder traversal of the BST
            void postorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                postorderTraversal(root->left);
                postorderTraversal(root->right);
                printf("%d ", root->data);
            }
            
            // Function to search for a node with a given value in the BST
            TreeNode* search(TreeNode* root, int value) {
                if (root == NULL || root->data == value) {
                    return root;
                }
            
                if (value < root->data) {
                    return search(root->left, value);
                }
            
                return search(root->right, value);
            }
            
            // Function to find the minimum value node in the BST
            TreeNode* findMinNode(TreeNode* node) {
                TreeNode* current = node;
                while (current && current->left != NULL) {
                    current = current->left;
                }
                return current;
            }
            
            // Function to delete a node with a given value from the BST
            TreeNode* deleteNode(TreeNode* root, int value) {
                if (root == NULL) {
                    return root;
                }
            
                if (value < root->data) {
                    root->left = deleteNode(root->left, value);
                } else if (value > root->data) {
                    root->right = deleteNode(root->right, value);
                } else {
                    if (root->left == NULL) {
                        TreeNode* temp = root->right;
                        free(root);
                        return temp;
                    } else if (root->right == NULL) {
                        TreeNode* temp = root->left;
                        free(root);
                        return temp;
                    }
                    TreeNode* temp = findMinNode(root->right);
                    root->data = temp->data;
                    root->right = deleteNode(root->right, temp->data);
                }
                return root;
            }
            
            // Function to free the memory of the BST nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                TreeNode* root = NULL;
            
                // Insert elements into the BST
                int values[] = {50, 30, 70, 20, 40, 60, 80};
                int numValues = sizeof(values) / sizeof(values[0]);
                for (int i = 0; i < numValues; i++) {
                    root = insert(root, values[i]);
                }
            
                printf("Inorder Traversal: ");
                inorderTraversal(root);
                printf("\n");
            
                printf("Preorder Traversal: ");
                preorderTraversal(root);
                printf("\n");
            
                printf("Postorder Traversal: ");
                postorderTraversal(root);
                printf("\n");
            
                int minValue = findMinimum(root);
                printf("Minimum Element in BST: %d\n", minValue);
            
                int searchValue = 40;
                TreeNode* foundNode = search(root, searchValue);
                if (foundNode != NULL) {
                    printf("Node with value %d found in BST.\n", searchValue);
                } else {
                    printf("Node with value %d not found in BST.\n", searchValue);
                }
            
                int deleteValue = 30;
                root = deleteNode(root, deleteValue);
                printf("Inorder Traversal after deleting %d: ", deleteValue);
                inorderTraversal(root);
                printf("\n");
            
                // Free the memory used by the tree nodes
                freeTree(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Inorder Traversal: 20 30 40 50 60 70 80
            Preorder Traversal: 50 30 20 40 70 60 80
            Postorder Traversal: 20 40 30 60 80 70 50
            Minimum Element in BST: 20
            Node with value 40 found in BST.
            Inorder Traversal after deleting 30: 20 40 50 60 70 80
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree8">
                <pre>
                <p>Question No. - 8. CREATE BINARY SEARCH TREE DYNAMICALLY (INSERT, DELETE, SEARCH, PREORDER, INORDER, POSTORDER, MINIMUM ELEMENT)
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a BST node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new BST node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert a new node in the BST
            TreeNode* insert(TreeNode* root, int data) {
                if (root == NULL) {
                    return createNode(data);
                }
            
                if (data < root->data) {
                    root->left = insert(root->left, data);
                } else if (data > root->data) {
                    root->right = insert(root->right, data);
                }
            
                return root;
            }
            
            // Function to find the minimum element in the BST
            int findMinimum(TreeNode* root) {
                if (root == NULL) {
                    printf("The tree is empty. Minimum element not found.\n");
                    return -1;
                }
            
                while (root->left != NULL) {
                    root = root->left;
                }
            
                return root->data;
            }
            
            // Function to perform an inorder traversal of the BST
            void inorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                inorderTraversal(root->left);
                printf("%d ", root->data);
                inorderTraversal(root->right);
            }
            
            // Function to perform a preorder traversal of the BST
            void preorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                printf("%d ", root->data);
                preorderTraversal(root->left);
                preorderTraversal(root->right);
            }
            
            // Function to perform a postorder traversal of the BST
            void postorderTraversal(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                postorderTraversal(root->left);
                postorderTraversal(root->right);
                printf("%d ", root->data);
            }
            
            // Function to search for a node with a given value in the BST
            TreeNode* search(TreeNode* root, int value) {
                if (root == NULL || root->data == value) {
                    return root;
                }
            
                if (value < root->data) {
                    return search(root->left, value);
                }
            
                return search(root->right, value);
            }
            
            // Function to find the minimum value node in the BST
            TreeNode* findMinNode(TreeNode* node) {
                TreeNode* current = node;
                while (current && current->left != NULL) {
                    current = current->left;
                }
                return current;
            }
            
            // Function to delete a node with a given value from the BST
            TreeNode* deleteNode(TreeNode* root, int value) {
                if (root == NULL) {
                    return root;
                }
            
                if (value < root->data) {
                    root->left = deleteNode(root->left, value);
                } else if (value > root->data) {
                    root->right = deleteNode(root->right, value);
                } else {
                    if (root->left == NULL) {
                        TreeNode* temp = root->right;
                        free(root);
                        return temp;
                    } else if (root->right == NULL) {
                        TreeNode* temp = root->left;
                        free(root);
                        return temp;
                    }
                    TreeNode* temp = findMinNode(root->right);
                    root->data = temp->data;
                    root->right = deleteNode(root->right, temp->data);
                }
                return root;
            }
            
            // Function to free the memory of the BST nodes
            void freeTree(TreeNode* root) {
                if (root == NULL) {
                    return;
                }
                freeTree(root->left);
                freeTree(root->right);
                free(root);
            }
            
            int main() {
                TreeNode* root = NULL;
                int choice, value;
            
                while (1) {
                    printf("\nBinary Search Tree Operations:\n");
                    printf("1. Insert\n");
                    printf("2. Delete\n");
                    printf("3. Search\n");
                    printf("4. Inorder Traversal\n");
                    printf("5. Preorder Traversal\n");
                    printf("6. Postorder Traversal\n");
                    printf("7. Find Minimum Element\n");
                    printf("8. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter value to insert: ");
                            scanf("%d", &value);
                            root = insert(root, value);
                            break;
            
                        case 2:
                            printf("Enter value to delete: ");
                            scanf("%d", &value);
                            root = deleteNode(root, value);
                            break;
            
                        case 3:
                            printf("Enter value to search: ");
                            scanf("%d", &value);
                            TreeNode* foundNode = search(root, value);
                            if (foundNode != NULL) {
                                printf("Node with value %d found in BST.\n", value);
                            } else {
                                printf("Node with value %d not found in BST.\n", value);
                            }
                            break;
            
                        case 4:
                            printf("Inorder Traversal: ");
                            inorderTraversal(root);
                            printf("\n");
                            break;
            
                        case 5:
                            printf("Preorder Traversal: ");
                            preorderTraversal(root);
                            printf("\n");
                            break;
            
                        case 6:
                            printf("Postorder Traversal: ");
                            postorderTraversal(root);
                            printf("\n");
                            break;
            
                        case 7:
                            value = findMinimum(root);
                            if (value != -1) {
                                printf("Minimum Element in BST: %d\n", value);
                            }
                            break;
            
                        case 8:
                            freeTree(root);
                            exit(0);
                            break;
            
                        default:
                            printf("Invalid choice. Please enter a valid option.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 1
            Enter value to insert: 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 1
            Enter value to insert: 30
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 1
            Enter value to insert: 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 4
            Inorder Traversal: 30 50 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 5
            Preorder Traversal: 50 30 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 6
            Postorder Traversal: 30 70 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 7
            Minimum Element in BST: 30
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 3
            Enter value to search: 70
            Node with value 70 found in BST.
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 2
            Enter value to delete: 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 4
            Inorder Traversal: 30 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Delete
            3. Search
            4. Inorder Traversal
            5. Preorder Traversal
            6. Postorder Traversal
            7. Find Minimum Element
            8. Exit
            Enter your choice: 8
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree9">
                <pre>
                <p>Question No. - 9. FIND INORDER PREDECESSOR AND INORDER SUCCESSOR OF BINARY SEARCH TREE (DYNAMICALLY REPRESENTED)
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Define a structure for a BST node
            struct TreeNode {
                int data;
                struct TreeNode* left;
                struct TreeNode* right;
            };
            
            typedef struct TreeNode TreeNode;
            
            // Function to create a new BST node
            TreeNode* createNode(int data) {
                TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert a new node in the BST
            TreeNode* insert(TreeNode* root, int data) {
                if (root == NULL) {
                    return createNode(data);
                }
            
                if (data < root->data) {
                    root->left = insert(root->left, data);
                } else if (data > root->data) {
                    root->right = insert(root->right, data);
                }
            
                return root;
            }
            
            // Function to find a node with a given value in the BST
            TreeNode* search(TreeNode* root, int value) {
                if (root == NULL || root->data == value) {
                    return root;
                }
            
                if (value < root->data) {
                    return search(root->left, value);
                }
            
                return search(root->right, value);
            }
            
            // Function to find the maximum value node in the BST (for predecessor)
            TreeNode* findMaxNode(TreeNode* node) {
                while (node->right != NULL) {
                    node = node->right;
                }
                return node;
            }
            
            // Function to find the minimum value node in the BST (for successor)
            TreeNode* findMinNode(TreeNode* node) {
                while (node->left != NULL) {
                    node = node->left;
                }
                return node;
            }
            
            // Find the inorder predecessor and successor
            void findPredecessorAndSuccessor(TreeNode* root, int value, TreeNode** predecessor, TreeNode** successor) {
                if (root == NULL) {
                    *predecessor = NULL;
                    *successor = NULL;
                    return;
                }
            
                // Search for the node with the given value
                TreeNode* current = root;
                while (current) {
                    if (current->data == value) {
                        // If the node is found, find its predecessor and successor
                        if (current->left) {
                            *predecessor = findMaxNode(current->left);
                        }
                        if (current->right) {
                            *successor = findMinNode(current->right);
                        }
                        return;
                    } else if (current->data > value) {
                        *successor = current;
                        current = current->left;
                    } else {
                        *predecessor = current;
                        current = current->right;
                    }
                }
            }
            
            int main() {
                TreeNode* root = NULL;
                int choice, value;
                TreeNode* predecessor = NULL;
                TreeNode* successor = NULL;
            
                while (1) {
                    printf("\nBinary Search Tree Operations:\n");
                    printf("1. Insert\n");
                    printf("2. Find Inorder Predecessor and Successor\n");
                    printf("3. Exit\n");
                    printf("Enter your choice: ");
                    scanf("%d", &choice);
            
                    switch (choice) {
                        case 1:
                            printf("Enter value to insert: ");
                            scanf("%d", &value);
                            root = insert(root, value);
                            break;
            
                        case 2:
                            printf("Enter value to find predecessor and successor: ");
                            scanf("%d", &value);
                            findPredecessorAndSuccessor(root, value, &predecessor, &successor);
                            if (predecessor != NULL) {
                                printf("Inorder Predecessor: %d\n", predecessor->data);
                            } else {
                                printf("Inorder Predecessor: N/A\n");
                            }
                            if (successor != NULL) {
                                printf("Inorder Successor: %d\n", successor->data);
                            } else {
                                printf("Inorder Successor: N/A\n");
                            }
                            break;
            
                        case 3:
                            // Exit the program
                            exit(0);
                            break;
            
                        default:
                            printf("Invalid choice. Please enter a valid option.\n");
                    }
                }
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 1
            Enter value to insert: 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 1
            Enter value to insert: 30
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 1
            Enter value to insert: 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 2
            Enter value to find predecessor and successor: 50
            Inorder Predecessor: 30
            Inorder Successor: 70
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 2
            Enter value to find predecessor and successor: 30
            Inorder Predecessor: N/A
            Inorder Successor: 50
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 2
            Enter value to find predecessor and successor: 70
            Inorder Predecessor: 50
            Inorder Successor: N/A
            
            Binary Search Tree Operations:
            1. Insert
            2. Find Inorder Predecessor and Successor
            3. Exit
            Enter your choice: 3
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
             
            <div id="tree10">
                <pre>
                <p>Question No. - 10. CHECK WHETHER BINARY SEARCH TREE CONTAINS DEAD END
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            #include &ltstdbool.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            struct Node *newNode(int data) {
                struct Node *node = (struct Node *)malloc(sizeof(struct Node));
                node->data = data;
                node->left = node->right = NULL;
                return node;
            }
            
            bool isDeadEnd(struct Node *root, int min, int max) {
                if (root == NULL) return false;
            
                if (min == max) return true;
            
                return isDeadEnd(root->left, min, root->data - 1) || isDeadEnd(root->right, root->data + 1, max);
            }
            
            bool containsDeadEnd(struct Node *root) {
                return isDeadEnd(root, 1, INT_MAX);
            }
            
            int main() {
                struct Node *root = newNode(8);
                root->left = newNode(5);
                root->right = newNode(9);
                root->left->left = newNode(2);
                root->left->right = newNode(7);
                root->right->right = newNode(12);
            
                if (containsDeadEnd(root))
                    printf("Binary Search Tree contains a dead end.");
                else
                    printf("Binary Search Tree does not contain a dead end.");
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Binary Search Tree contains a dead end.
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree11">
                <pre>
                <p>Question No. - 11. CREATE BINARY TREE TO BINARY SEARCH TREE THROUGH ARRAY.
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            void storeInorder(struct Node* node, int inorder[], int* index_ptr) {
                if (node == NULL) return;
            
                storeInorder(node->left, inorder, index_ptr);
            
                inorder[*index_ptr] = node->data;
                (*index_ptr)++;
            
                storeInorder(node->right, inorder, index_ptr);
            }
            
            void arrayToBST(int* arr, struct Node* root, int* index_ptr) {
                if (root == NULL) return;
            
                arrayToBST(arr, root->left, index_ptr);
            
                root->data = arr[*index_ptr];
                (*index_ptr)++;
            
                arrayToBST(arr, root->right, index_ptr);
            }
            
            struct Node* binaryTreeToBST(struct Node* root) {
                if (root == NULL) return NULL;
            
                int n = 0;
                storeInorder(root, NULL, &n);
            
                int* arr = (int*)malloc(n * sizeof(int));
                n = 0;
                storeInorder(root, arr, &n);
            
                qsort(arr, n, sizeof(arr[0]), (int (*)(const void*, const void*))compare);
            
                n = 0;
                arrayToBST(arr, root, &n);
            
                free(arr);
                return root;
            }
            
            struct Node* newNode(int data) {
                struct Node* node = (struct Node*)malloc(sizeof(struct Node));
                node->data = data;
                node->left = node->right = NULL;
                return node;
            }
            
            void printInorder(struct Node* node) {
                if (node == NULL) return;
            
                printInorder(node->left);
                printf("%d ", node->data);
                printInorder(node->right);
            }
            
            int compare(const void* a, const void* b) {
                return (*(int*)a - *(int*)b);
            }
            
            int main() {
                struct Node* root = newNode(10);
                root->left = newNode(30);
                root->right = newNode(15);
                root->left->left = newNode(20);
                root->right->right = newNode(5);
            
                printf("Inorder traversal of the constructed binary tree: \n");
                printInorder(root);
            
                root = binaryTreeToBST(root);
            
                printf("\nInorder traversal of the converted binary search tree: \n");
                printInorder(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Inorder traversal of the constructed binary tree: 
            20 30 10 15 5 
            Inorder traversal of the converted binary search tree: 
            5 10 15 20 30
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree12">
                <pre>
                <p>Question No. - 12. FIND KTH LARGEST ELEMENT IN BINARY SEARCH TREE THROUGH ARRAY
                </p>
                <code>
            #include &ltstdio.h>
            
            int kthLargest(int arr[], int size, int k) {
                if (k > 0 && k <= size) {
                    return arr[size - k];
                }
                return -1;
            }
            
            int main() {
                int size, k;
            
                printf("Enter the size of the binary search tree: ");
                scanf("%d", &size);
            
                int bst[size];
            
                printf("Enter the elements of the binary search tree:\n");
                for (int i = 0; i < size; i++) {
                    scanf("%d", &bst[i]);
                }
            
                printf("Enter the value of K: ");
                scanf("%d", &k);
            
                int result = kthLargest(bst, size, k);
            
                if (result != -1) {
                    printf("The %dth largest element in the binary search tree is: %d", k, result);
                } else {
                    printf("Invalid input. The element does not exist.");
                }
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Enter the size of the binary search tree: 7
            Enter the elements of the binary search tree:
            4
            8
            10
            12
            15
            18
            20
            Enter the value of K: 3
            The 3rd largest element in the binary search tree is: 15
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree13">
                <pre>
                <p>Question No. - 13. FIND KTH SMALLEST ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY
                </p>
                <code>
            #include &ltstdio.h>
            
            int kthSmallest(int arr[], int size, int k) {
                if (k > 0 && k <= size) {
                    return arr[k - 1];
                }
                return -1;
            }
            
            int main() {
                int bst[] = {2, 3, 4, 5, 6, 8, 9};
                int size = sizeof(bst) / sizeof(bst[0]);
                int k = 3;
            
                int result = kthSmallest(bst, size, k);
            
                if (result != -1) {
                    printf("The %dth smallest element in the binary search tree is: %d", k, result);
                } else {
                    printf("Invalid input. The element does not exist.");
                }
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            The 3rd smallest element in the binary search tree is: 4
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree14">
                <pre>
                <p>Question No. - 14. PRINT PREORDER TRAVERSAL TO POSTORDER TRAVERSAL OF BINARY SEARCH TREE
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = newNode->right = NULL;
                return newNode;
            }
            
            struct Node* constructBST(int preorder[], int* preIndex, int key, int min, int max, int size) {
                if (*preIndex >= size) {
                    return NULL;
                }
            
                struct Node* root = NULL;
            
                if (key > min && key < max) {
                    root = createNode(key);
                    *preIndex = *preIndex + 1;
            
                    if (*preIndex < size) {
                        root->left = constructBST(preorder, preIndex, preorder[*preIndex], min, key, size);
                        root->right = constructBST(preorder, preIndex, preorder[*preIndex], key, max, size);
                    }
                }
                return root;
            }
            
            void postorderTraversal(struct Node* root) {
                if (root != NULL) {
                    postorderTraversal(root->left);
                    postorderTraversal(root->right);
                    printf("%d ", root->data);
                }
            }
            
            int main() {
                int preorder[] = {8, 5, 3, 6, 10, 9, 12};
                int size = sizeof(preorder) / sizeof(preorder[0]);
                int preIndex = 0;
            
                struct Node* root = constructBST(preorder, &preIndex, preorder[preIndex], INT_MIN, INT_MAX, size);
            
                printf("Postorder traversal of the constructed BST: ");
                postorderTraversal(root);
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Postorder traversal of the constructed BST: 3 6 5 9 12 10 8
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree15">
                <pre>
                <p>Question No. - 15. CONSTRUCT BINARY SEARCH TREE FROM GIVEN PREORDER TRAVERSAL THROUGH ARRAYS
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = newNode->right = NULL;
                return newNode;
            }
            
            struct Node* constructBST(int preorder[], int* preIndex, int key, int min, int max, int size) {
                if (*preIndex >= size) {
                    return NULL;
                }
            
                struct Node* root = NULL;
            
                if (key > min && key < max) {
                    root = createNode(key);
                    *preIndex = *preIndex + 1;
            
                    if (*preIndex < size) {
                        root->left = constructBST(preorder, preIndex, preorder[*preIndex], min, key, size);
                        root->right = constructBST(preorder, preIndex, preorder[*preIndex], key, max, size);
                    }
                }
                return root;
            }
            
            void inorderTraversal(struct Node* root) {
                if (root != NULL) {
                    inorderTraversal(root->left);
                    printf("%d ", root->data);
                    inorderTraversal(root->right);
                }
            }
            
            int main() {
                int preorder[] = {5, 3, 2, 4, 8, 6, 9};
                int size = sizeof(preorder) / sizeof(preorder[0]);
                int preIndex = 0;
            
                struct Node* root = constructBST(preorder, &preIndex, preorder[preIndex], INT_MIN, INT_MAX, size);
            
                printf("Inorder traversal of the constructed BST: ");
                inorderTraversal(root);
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Inorder traversal of the constructed BST: 2 3 4 5 6 8 9
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree16">
                <pre>
                <p>Question No. - 16. CONSTRUCT BINARY SEARCH TREE FROM GIVEN POSTORDER TRAVERSAL THROUGH ARRAYS
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node *left, *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = newNode->right = NULL;
                return newNode;
            }
            
            struct Node* constructBST(int postorder[], int* postIndex, int key, int min, int max, int size) {
                if (*postIndex < 0) {
                    return NULL;
                }
            
                struct Node* root = NULL;
            
                if (key > min && key < max) {
                    root = createNode(key);
                    *postIndex = *postIndex - 1;
            
                    if (*postIndex >= 0) {
                        root->right = constructBST(postorder, postIndex, postorder[*postIndex], key, max, size);
                        root->left = constructBST(postorder, postIndex, postorder[*postIndex], min, key, size);
                    }
                }
                return root;
            }
            
            void inorderTraversal(struct Node* root) {
                if (root != NULL) {
                    inorderTraversal(root->left);
                    printf("%d ", root->data);
                    inorderTraversal(root->right);
                }
            }
            
            int main() {
                int postorder[] = {1, 3, 2, 7, 9, 8, 5};
                int size = sizeof(postorder) / sizeof(postorder[0]);
                int postIndex = size - 1;
            
                struct Node* root = constructBST(postorder, &postIndex, postorder[postIndex], INT_MIN, INT_MAX, size);
            
                printf("Inorder traversal of the constructed BST: ");
                inorderTraversal(root);
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Inorder traversal of the constructed BST: 1 2 3 5 7 8 9
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree17">
                <pre>
                <p>Question No. - 17. CREATE STRICTLY BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node *left;
                struct Node *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            struct Node* insertNode(struct Node* root, int data) {
                if (root == NULL) {
                    root = createNode(data);
                } else {
                    printf("Node already exists.\n");
                }
                return root;
            }
            
            void inorderTraversal(struct Node* root) {
                if (root != NULL) {
                    inorderTraversal(root->left);
                    printf("%d ", root->data);
                    inorderTraversal(root->right);
                }
            }
            
            int main() {
                struct Node* root = NULL;
                int n;
                printf("Enter the number of nodes in the strictly binary tree: ");
                scanf("%d", &n);
            
                int arr[n];
                printf("Enter the elements: ");
                for (int i = 0; i < n; i++) {
                    scanf("%d", &arr[i]);
                    root = insertNode(root, arr[i]);
                }
            
                printf("Inorder traversal of the strictly binary tree: ");
                inorderTraversal(root);
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Enter the number of nodes in the strictly binary tree: 5
            Enter the elements: 1 2 3 4 5
            Node already exists.
            Inorder traversal of the strictly binary tree: 1 2 3 4 5
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree18">
                <pre>
                <p>Question No. - 18. CREATE ALMOST COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Structure for a binary tree node
            struct Node {
                int data;
                struct Node *left;
                struct Node *right;
            };
            
            // Function to create a new node
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert nodes in level order
            struct Node* insertLevelOrder(int arr[], struct Node* root, int i, int n) {
                // Base case for recursion
                if (i < n) {
                    struct Node* temp = createNode(arr[i]);
                    root = temp;
            
                    // Insert left child
                    root->left = insertLevelOrder(arr, root->left, 2 * i + 1, n);
            
                    // Insert right child
                    if (2 * i + 2 < n) {
                        root->right = insertLevelOrder(arr, root->right, 2 * i + 2, n);
                    }
                }
                return root;
            }
            
            // Function to traverse the binary tree in preorder
            void preorder(struct Node* root) {
                if (root != NULL) {
                    printf("%d ", root->data);
                    preorder(root->left);
                    preorder(root->right);
                }
            }
            
            // Driver code
            int main() {
                struct Node* root = NULL;
                int n;
                printf("Enter the number of nodes in the almost complete binary tree: ");
                scanf("%d", &n);
            
                int arr[n];
                printf("Enter the elements: ");
                for (int i = 0; i < n; i++) {
                    scanf("%d", &arr[i]);
                }
            
                root = insertLevelOrder(arr, root, 0, n);
                printf("Preorder traversal of the almost complete binary tree: ");
                preorder(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Enter the number of nodes in the almost complete binary tree: 5
            Enter the elements: 1 2 3 4 5
            Preorder traversal of the almost complete binary tree: 1 2 4 5 3
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree19">
                <pre>
                <p>Question No. - 19. CREATE COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            // Structure for a binary tree node
            struct Node {
                int data;
                struct Node *left;
                struct Node *right;
            };
            
            // Function to create a new node
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            // Function to insert nodes in level order
            struct Node* insertLevelOrder(int arr[], struct Node* root, int i, int n) {
                // Base case for recursion
                if (i < n) {
                    struct Node* temp = createNode(arr[i]);
                    root = temp;
            
                    // Insert left child
                    root->left = insertLevelOrder(arr, root->left, 2 * i + 1, n);
            
                    // Insert right child
                    root->right = insertLevelOrder(arr, root->right, 2 * i + 2, n);
                }
                return root;
            }
            
            // Function to traverse the binary tree in preorder
            void preorder(struct Node* root) {
                if (root != NULL) {
                    printf("%d ", root->data);
                    preorder(root->left);
                    preorder(root->right);
                }
            }
            
            // Driver code
            int main() {
                struct Node* root = NULL;
                int n;
                printf("Enter the number of nodes in the binary tree: ");
                scanf("%d", &n);
            
                int arr[n];
                printf("Enter the elements: ");
                for (int i = 0; i < n; i++) {
                    scanf("%d", &arr[i]);
                }
            
                root = insertLevelOrder(arr, root, 0, n);
                printf("Preorder traversal of the complete binary tree: ");
                preorder(root);
            
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Enter the number of nodes in the binary tree: 5
            Enter the elements: 1 2 3 4 5
            Preorder traversal of the complete binary tree: 1 2 4 5 3 
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            <div id="tree20">
                <pre>
                <p>Question No. - 20. COUNT THE NUMBER OF NODES IN BINARY SEARCH TREE CONSTRUCTED DYNAMICALLY
                </p>
                <code>
            #include &ltstdio.h>
            #include &ltstdlib.h>
            
            struct Node {
                int data;
                struct Node *left;
                struct Node *right;
            };
            
            struct Node* createNode(int data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode->data = data;
                newNode->left = NULL;
                newNode->right = NULL;
                return newNode;
            }
            
            struct Node* insert(struct Node* root, int data) {
                if (root == NULL) {
                    return createNode(data);
                }
            
                if (data < root->data) {
                    root->left = insert(root->left, data);
                } else if (data > root->data) {
                    root->right = insert(root->right, data);
                }
            
                return root;
            }
            
            int countNodes(struct Node* root) {
                if (root == NULL) {
                    return 0;
                }
                return 1 + countNodes(root->left) + countNodes(root->right);
            }
            
            int main() {
                struct Node* root = NULL;
                int n, data;
                printf("Enter the number of nodes you want to insert: ");
                scanf("%d", &n);
                printf("Enter the elements:\n");
                for (int i = 0; i < n; i++) {
                    scanf("%d", &data);
                    root = insert(root, data);
                }
            
                printf("Number of nodes in the BST is %d", countNodes(root));
                return 0;
            }
            
                </code>
                <p>Output-</p>
                <code>
            Enter the number of nodes you want to insert: 7
            Enter the elements:
            5
            3
            7
            2
            4
            6
            8
            Number of nodes in the BST is 7
            
                </code>
                </pre>
                <div class="borderline"></div>
            </div> 
            
             
            
            

            
            
            
            
            
            
            
            
            
            
            
            
            
            
                        



        
        
        
        
        
        </div>
    </main>
</body>
